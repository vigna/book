<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>The Rust Rand Book</title>
        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="Extended documentation for Rust's Rand lib">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link href="https://fonts.googleapis.com/css?family=Open+Sans:300italic,400italic,600italic,700italic,800italic,400,300,600,700,800" rel="stylesheet" type="text/css">
        <link href="https://fonts.googleapis.com/css?family=Source+Code+Pro:500" rel="stylesheet" type="text/css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        

        
    </head>
    <body class="light">
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "";
            var default_theme = "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { } 
            if (theme === null || theme === undefined) { theme = default_theme; }
            document.body.className = theme;
            document.querySelector('html').className = theme + ' js';
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <ol class="chapter"><li class="affix"><a href="intro.html">Introduction</a></li><li><a href="crates.html"><strong aria-hidden="true">1.</strong> Crates</a></li><li><a href="features.html"><strong aria-hidden="true">2.</strong> Feature flags</a></li><li><a href="guide.html"><strong aria-hidden="true">3.</strong> Guide</a></li><li><ol class="section"><li><a href="guide-start.html"><strong aria-hidden="true">3.1.</strong> Getting Started</a></li><li><a href="guide-data.html"><strong aria-hidden="true">3.2.</strong> Random data</a></li><li><a href="guide-gen.html"><strong aria-hidden="true">3.3.</strong> Random generators</a></li><li><a href="guide-rngs.html"><strong aria-hidden="true">3.4.</strong> Our RNGs</a></li><li><a href="guide-values.html"><strong aria-hidden="true">3.5.</strong> Random values</a></li><li><a href="guide-dist.html"><strong aria-hidden="true">3.6.</strong> Random distributions</a></li><li><a href="guide-seq.html"><strong aria-hidden="true">3.7.</strong> Sequences</a></li><li><a href="guide-err.html"><strong aria-hidden="true">3.8.</strong> Error handling</a></li></ol></li><li><a href="portability.html"><strong aria-hidden="true">4.</strong> Portability</a></li><li><a href="update.html"><strong aria-hidden="true">5.</strong> Updating</a></li><li><ol class="section"><li><a href="update-0.5.html"><strong aria-hidden="true">5.1.</strong> Updating to 0.5</a></li><li><a href="update-0.6.html"><strong aria-hidden="true">5.2.</strong> Updating to 0.6</a></li><li><a href="update-0.7.html"><strong aria-hidden="true">5.3.</strong> Updating to 0.7</a></li></ol></li><li><a href="contributing.html"><strong aria-hidden="true">6.</strong> Contributing</a></li><li><ol class="section"><li><a href="contrib-doc.html"><strong aria-hidden="true">6.1.</strong> Documentation</a></li><li><a href="contrib-scope.html"><strong aria-hidden="true">6.2.</strong> Scope</a></li><li><a href="contrib-test.html"><strong aria-hidden="true">6.3.</strong> Testing</a></li><li><a href="contrib-bench.html"><strong aria-hidden="true">6.4.</strong> Benchmarks</a></li></ol></li></ol>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                
                <div id="menu-bar" class="menu-bar">
                    <div id="menu-bar-sticky-container">
                        <div class="left-buttons">
                            <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                                <i class="fa fa-bars"></i>
                            </button>
                            <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                                <i class="fa fa-paint-brush"></i>
                            </button>
                            <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                                <li role="none"><button role="menuitem" class="theme" id="light">Light (default)</button></li>
                                <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                                <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                                <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                                <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                            </ul>
                            
                            <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                                <i class="fa fa-search"></i>
                            </button>
                            
                        </div>

                        <h1 class="menu-title">The Rust Rand Book</h1> 

                        <div class="right-buttons">
                            <a href="print.html" title="Print this book" aria-label="Print this book">
                                <i id="print-button" class="fa fa-print"></i>
                            </a>
                            
                        </div>
                    </div>
                </div>

                
                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" name="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>
                

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <a class="header" href="#the-rust-rand-book" id="the-rust-rand-book"><h1>The Rust Rand Book</h1></a>
<p>This is the extended documentation for Rust's <strong>Rand</strong>om number library.</p>
<p>This book contains:</p>
<ol>
<li>An overview of <a href="crates.html">crates and functionality</a></li>
<li>Documentation of crate <a href="features.html">feature flags</a></li>
<li>The <a href="guide.html">Users' Guide</a></li>
<li>Notes on <a href="portability.html">Portability and Reproducibility</a>.
(Read this if you want reproducibility across builds.)</li>
<li><a href="update.html">Updating guides</a></li>
<li><a href="contributing.html">Contributor's guide</a></li>
</ol>
<p>Outside this book, you may want:</p>
<ul>
<li><a href="https://docs.rs/rand/">API reference for the latest release</a></li>
<li><a href="https://rust-random.github.io/rand/">API reference for the master branch</a></li>
<li><a href="https://github.com/rust-random/rand/">The Rand repository</a></li>
<li><a href="https://github.com/rust-random/book/">The Book source</a></li>
</ul>
<a class="header" href="#crates" id="crates"><h1>Crates</h1></a>
<p>The Rand library consists of a family of crates. For common usage, the <code>rand</code>
crate alone will often suffice. Other crates serve as building-blocks and/or
provide additional functionality.</p>
<a class="header" href="#rand_core" id="rand_core"><h3>rand_core</h3></a>
<p>The <a href="https://rust-random.github.io/rand/rand_core/index.html"><code>rand_core</code></a> crate defines the core traits implemented by RNGs. This exists
as a separate crate with two purposes:</p>
<ul>
<li>to provide a minimal API for defining and using RNGs</li>
<li>to provide tools to aid implementation of RNGs</li>
</ul>
<p>The <a href="https://rust-random.github.io/rand/rand_core/trait.RngCore.html"><code>RngCore</code></a>, <a href="https://rust-random.github.io/rand/rand_core/trait.SeedableRng.html"><code>SeedableRng</code></a>, <a href="https://rust-random.github.io/rand/rand_core/trait.CryptoRng.html"><code>CryptoRng</code></a> traits and <a href="https://rust-random.github.io/rand/rand_core/struct.Error.html"><code>Error</code></a> type are
all defined by this crate and re-exported by the <a href="https://rust-random.github.io/rand/rand/index.html"><code>rand</code></a> crate.</p>
<a class="header" href="#rand" id="rand"><h3>rand</h3></a>
<p>The <a href="https://rust-random.github.io/rand/rand/index.html"><code>rand</code></a> crate is optimised for easy usage of common random-number
functionality. This has several aspects:</p>
<ul>
<li>the <a href="https://rust-random.github.io/rand/rand/rngs/index.html"><code>rngs</code></a> module provides a few convenient generators</li>
<li>the <a href="https://rust-random.github.io/rand/rand/distributions/index.html"><code>distributions</code></a> module concerns sampling of random values</li>
<li>the <a href="https://rust-random.github.io/rand/rand/seq/index.html"><code>seq</code></a> module concerns sampling from and shuffling sequences</li>
<li>the <a href="https://rust-random.github.io/rand/rand/trait.Rng.html"><code>Rng</code></a> trait provides a few convenience methods for generating
random values</li>
<li>the <a href="https://rust-random.github.io/rand/rand/fn.random.html"><code>random</code></a> function provides convenient generation in a single call</li>
</ul>
<a class="header" href="#distributions" id="distributions"><h2>Distributions</h2></a>
<p>The <a href="https://rust-random.github.io/rand/rand/index.html"><code>rand</code></a> crate only implements sampling from the most common random
number distributions: uniform and weighted sampling. For everything else,</p>
<ul>
<li><a href="https://rust-random.github.io/rand/rand_distr/index.html"><code>rand_distr</code></a> provides fast sampling from a variety of other distributions,
including Normal (Gauss), Binomial, Poisson, UnitCircle, and many more</li>
<li><a href="https://github.com/boxtown/statrs"><code>statrs</code></a> is a port of the C# Math.NET library, implementing many of the
same distributions (plus/minus a few), along with PDF and CDF functions,
the <em>error</em>, <em>beta</em>, <em>gamma</em> and <em>logistic</em> special functions, plus a few
utilities. (For clarity, <a href="https://github.com/boxtown/statrs"><code>statrs</code></a> is not part of the Rand library.)</li>
</ul>
<a class="header" href="#generators" id="generators"><h2>Generators</h2></a>
<a class="header" href="#deterministic-generators" id="deterministic-generators"><h3>Deterministic generators</h3></a>
<p>The following crates implement [PRNGs]:</p>
<ul>
<li><a href="https://rust-random.github.io/rand/rand_chacha/index.html"><code>rand_chacha</code></a> provides generators using the ChaCha cipher</li>
<li><a href="https://rust-random.github.io/rand/rand_hc/index.html"><code>rand_hc</code></a> implements a generator using the HC-128 cipher</li>
<li><a href="https://rust-random.github.io/rand/rand_isaac/index.html"><code>rand_isaac</code></a> implements the ISAAC generators</li>
<li><a href="https://rust-random.github.io/rand/rand_pcg/index.html"><code>rand_pcg</code></a> implements a small selection of PCG generators</li>
<li><a href="https://rust-random.github.io/rand/rand_xoshiro/index.html"><code>rand_xoshiro</code></a> implements the SplitMix and Xoshiro generators</li>
<li><a href="https://rust-random.github.io/rand/rand_xorshift/index.html"><code>rand_xorshift</code></a> implements the basic Xorshift generator</li>
</ul>
<a class="header" href="#non-deterministic-generators" id="non-deterministic-generators"><h3>Non-deterministic generators</h3></a>
<p>The following crates provide non-deterministic random data:</p>
<ul>
<li><a href="https://docs.rs/getrandom/"><code>getrandom</code></a> provides an interface to system-specific random data sources</li>
<li><a href="https://rust-random.github.io/rand/rand_os/index.html"><code>rand_os</code></a> provides a simple RNG wrapping <a href="https://docs.rs/getrandom/"><code>getrandom</code></a> functionality
(this wrapper is duplicated by the <a href="https://rust-random.github.io/rand/rand/index.html"><code>rand</code></a> crate)</li>
<li><a href="https://rust-random.github.io/rand/rand_jitter/index.html"><code>rand_jitter</code></a> implements a CPU-jitter-based entropy harvestor</li>
</ul>
<a class="header" href="#feature-flags" id="feature-flags"><h1>Feature flags</h1></a>
<p>Some functionality is gated behind Cargo features, which must be enabled as
required, e.g.</p>
<pre><code>rand = { version = &quot;0.7&quot;, features = [&quot;log&quot;, &quot;serde1&quot;] }
</code></pre>
<a class="header" href="#small-rng" id="small-rng"><h3>Small RNG</h3></a>
<p>From Rand version 0.7, the <a href="https://rust-random.github.io/rand/rand/rngs/struct.SmallRng.html"><code>SmallRng</code></a> type is gated behind the <code>small_rng</code>
feature flag (this reduces <code>rand</code>'s depnedency count by one if not used).</p>
<a class="header" href="#logging" id="logging"><h3>Logging</h3></a>
<p>Rand can optionally log a few events (mostly related to reseeding of
<a href="https://rust-random.github.io/rand/rand/rngs/struct.ThreadRng.html"><code>ThreadRng</code></a> and to <a href="https://rust-random.github.io/rand/rand_jitter/index.html"><code>rand_jitter</code></a>).</p>
<a class="header" href="#serde" id="serde"><h3>Serde</h3></a>
<p>Some parts of the Rand lib support serialisation via <a href="https://serde.rs/">Serde</a>.
To enable this, use the <code>serde1</code> feature.</p>
<p>Note that cryptographic RNGs <em>do not</em> support serialisation since this could be
a security risk. If you need state-restore functionality on a cryptographic RNG,
the ChaCha generator supports <a href="https://rust-random.github.io/rand/rand_chacha/struct.ChaCha20Rng.html#method.get_word_pos">getting and setting the stream position</a>,
which, together with the seed, can be used to reconstruct the generator's state.</p>
<a class="header" href="#simd-support" id="simd-support"><h3>SIMD support</h3></a>
<p>Experimental support for generating SIMD values is available under the
<code>simd_support</code> feature gate. This requires nightly Rust.</p>
<p>The ChaCha implementations provided by <a href="https://rust-random.github.io/rand/rand_chacha/index.html"><code>rand_chacha</code></a> use SIMD operations
internally even on stable Rust. This is enabled by default.</p>
<a class="header" href="#no-std-mode" id="no-std-mode"><h3>No-std mode</h3></a>
<p>Almost all Rand libraries can be used without Rust's standard library:</p>
<ul>
<li>For the <a href="https://rust-random.github.io/rand/rand/index.html"><code>rand</code></a> and <a href="https://rust-random.github.io/rand/rand_chacha/index.html"><code>rand_chacha</code></a> crates, one must disable default features
(<code>default-features = false</code>) and some functionality is lost.</li>
<li>The <a href="https://rust-random.github.io/rand/rand_core/index.html"><code>rand_core</code></a> and <a href="https://rust-random.github.io/rand/rand_jitter/index.html"><code>rand_jitter</code></a> crates assume <code>no_std</code> by default, but
support some additional functionality when the <code>std</code> feature is enabled.</li>
<li><a href="https://docs.rs/getrandom/"><code>getrandom</code></a> (and by extension <a href="https://rust-random.github.io/rand/rand_os/index.html"><code>rand_os</code></a>) has limited support for <code>no_std</code>.
It does not use feature flags, instead detecting requirements based on the target platform.</li>
<li>The <a href="https://rust-random.github.io/rand/rand_distr/index.html"><code>rand_distr</code></a> crate does not support <code>no_std</code> mode.</li>
<li>All PRNG crates other than <a href="https://rust-random.github.io/rand/rand_chacha/index.html"><code>rand_chacha</code></a> do not require <code>std</code>.</li>
</ul>
<p>If an allocator is available, some functionality can be recovered by use of the
<code>alloc</code> feature. On:</p>
<ul>
<li><a href="https://rust-random.github.io/rand/rand_core/index.html"><code>rand_core</code></a>, the <code>alloc</code> feature enables blanket trait impls for <code>Box&lt;T&gt;</code></li>
<li><a href="https://rust-random.github.io/rand/rand/index.html"><code>rand</code></a>, the <code>alloc</code> feature enables sequence-related functionality</li>
</ul>
<a class="header" href="#guide" id="guide"><h1>Guide</h1></a>
<p>This section attempts to explain some of the concepts used in this library.</p>
<ol>
<li><a href="guide-start.html">Intro: Hello Random example</a></li>
<li><a href="guide-data.html">What is random data and what is randomness anyway?</a></li>
<li><a href="guide-gen.html">What kind of random generators are there?</a></li>
<li><a href="guide-rngs.html">What random number generators does Rand provide?</a></li>
<li><a href="guide-values.html">Turning random data into useful values</a></li>
<li><a href="guide-dist.html">Distributions: more control over random values</a></li>
<li><a href="guide-seq.html">Sequences</a></li>
<li><a href="guide-err.html">Error handling</a></li>
</ol>
<a class="header" href="#importing-items-prelude" id="importing-items-prelude"><h2>Importing items (prelude)</h2></a>
<p>The most convenient way to import items from Rand is to use the <a href="../rand/rand/prelude/index.html"><code>prelude</code></a>.
This includes the most important parts of Rand, but only those unlikely to
cause name conflicts.</p>
<p>Note that Rand 0.5 has significantly changed the module organization and
contents relative to previous versions. Where possible old names have been
kept (but are hidden in the documentation), however these will be removed
in the future. We therefore recommend migrating to use the prelude or the
new module organization in your imports.</p>
<a class="header" href="#further-examples" id="further-examples"><h2>Further examples</h2></a>
<p>For some inspiration, see the example applications:</p>
<ul>
<li><a href="https://github.com/rust-random/rand/blob/master/examples/monte-carlo.rs">Monte Carlo estimation of π</a></li>
<li><a href="https://github.com/rust-random/rand/blob/master/examples/monty-hall.rs">Monty Hall Problem</a></li>
</ul>
<a class="header" href="#getting-started" id="getting-started"><h1>Getting Started</h1></a>
<p>Lets kick things off with an example (<a href="https://play.rust-lang.org/?version=stable&amp;mode=debug&amp;edition=2018&amp;gist=4cad6600b21578cfa22009c281c780fe">playground link</a>):</p>
<pre><pre class="playpen"><code class="language-rust editable"># extern crate rand;

// import commonly used items from the prelude:
use rand::prelude::*;

fn main() {
    // We can use random() immediately. It can produce values of many common types:
    let x: u8 = random();
    println!(&quot;{}&quot;, x);

    if random() { // generates a boolean
        println!(&quot;Heads!&quot;);
    }

    // If we want to be a bit more explicit (and a little more efficient) we can
    // make a handle to the thread-local generator:
    let mut rng = thread_rng();
    if rng.gen() { // random bool
        let x: f64 = rng.gen(); // random number in range [0, 1)
        let y = rng.gen_range(-10.0, 10.0);
        println!(&quot;x is: {}&quot;, x);
        println!(&quot;y is: {}&quot;, y);
        println!(&quot;Number from 0 to 9: {}&quot;, rng.gen_range(0, 10));
    }
    
    // Sometimes it's useful to use distributions directly:
    let distr = rand::distributions::Uniform::new_inclusive(1, 100);
    let mut nums = [0i32; 3];
    for x in &amp;mut nums {
        *x = rng.sample(distr);
    }
    println!(&quot;Some numbers: {:?}&quot;, nums);
    
    // We can also interact with iterators and slices:
    let arrows_iter = &quot;➡⬈⬆⬉⬅⬋⬇⬊&quot;.chars();
    println!(&quot;Lets go in this direction: {}&quot;, arrows_iter.choose(&amp;mut rng).unwrap());
    let mut nums = [1, 2, 3, 4, 5];
    nums.shuffle(&amp;mut rng);
    println!(&quot;I shuffled my {:?}&quot;, nums);
}
</code></pre></pre>
<p>The first thing you may have noticed is that we imported everything from the
<a href="https://rust-random.github.io/rand/rand/prelude/index.html">prelude</a>. This is the lazy way to <code>use</code> rand, and like the
<a href="https://doc.rust-lang.org/std/prelude/index.html">standard library's prelude</a>,
only imports the most common items. If you don't wish to use the prelude,
remember to import the <a href="https://rust-random.github.io/rand/rand/trait.Rng.html"><code>Rng</code></a> trait!</p>
<p>The Rand library automatically initialises a secure, thread-local generator
on demand. This can be accessed via the <a href="https://rust-random.github.io/rand/rand/fn.thread_rng.html"><code>thread_rng</code></a> and <a href="https://rust-random.github.io/rand/rand/fn.random.html"><code>random</code></a> functions.
For more on this topic, see <a href="guide-gen.html">Random generators</a>.</p>
<p>While the <a href="https://rust-random.github.io/rand/rand/fn.random.html"><code>random</code></a> function can only sample values in a <a href="https://rust-random.github.io/rand/rand/distributions/struct.Standard.html"><code>Standard</code></a>
(type-dependent) manner, <a href="https://rust-random.github.io/rand/rand/fn.thread_rng.html"><code>thread_rng</code></a> gives you a handle to a generator.
All generators implement the <a href="https://rust-random.github.io/rand/rand/trait.Rng.html"><code>Rng</code></a> trait, which provides the <a href="https://rust-random.github.io/rand/rand/trait.Rng.html#method.gen"><code>gen</code></a>,
<a href="https://rust-random.github.io/rand/rand/trait.Rng.html#method.gen_range"><code>gen_range</code></a> and <a href="https://rust-random.github.io/rand/rand/trait.Rng.html#method.sample"><code>sample</code></a> methods used above.</p>
<p>Rand provides functionality on iterators and slices via two more traits,
<a href="https://rust-random.github.io/rand/rand/seq/trait.IteratorRandom.html"><code>IteratorRandom</code></a> and <a href="https://rust-random.github.io/rand/rand/seq/trait.SliceRandom.html"><code>SliceRandom</code></a>.</p>
<a class="header" href="#fixed-seed-rngs" id="fixed-seed-rngs"><h2>Fixed seed RNGs</h2></a>
<p>You may have noticed the use of <code>thread_rng()</code> above and wondered how to
specify a fixed seed. To do so, you need to specify an RNG then use a method
like <a href="https://rust-random.github.io/rand/rand/trait.SeedableRng.html#method.seed_from_u64"><code>seed_from_u64</code></a> or <a href="https://rust-random.github.io/rand/rand/trait.SeedableRng.html#tymethod.from_seed"><code>from_seed</code></a>.</p>
<p>Note that <a href="https://rust-random.github.io/rand/rand/trait.SeedableRng.html#method.seed_from_u64"><code>seed_from_u64</code></a> is <strong>not suitable for cryptographic uses</strong> since a
single <code>u64</code> cannot provide sufficient entropy to securely seed an RNG.
All cryptographic RNGs accept a more appropriate seed via <a href="https://rust-random.github.io/rand/rand/trait.SeedableRng.html#tymethod.from_seed"><code>from_seed</code></a>.</p>
<p>We use <code>ChaCha8Rng</code> below because it is fast and portable with good quality.
See the <a href="guide-rngs.html">RNGs</a> section for more RNGs, but avoid <code>SmallRng</code> and <code>StdRng</code> if you
care about reproducible results.</p>
<pre><pre class="playpen"><code class="language-rust editable">extern crate rand;
extern crate rand_chacha;

use rand::{Rng, SeedableRng};

fn main() {
    let mut rng = rand_chacha::ChaCha8Rng::seed_from_u64(10);
    println!(&quot;Random f32: {}&quot;, rng.gen::&lt;f32&gt;());
}
</code></pre></pre>
<a class="header" href="#random-data" id="random-data"><h1>Random data</h1></a>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
# extern crate rand;
# use rand::RngCore;
// get some random data:
let mut data = [0u8; 32];
rand::thread_rng().fill_bytes(&amp;mut data);
#}</code></pre></pre>
<a class="header" href="#what-is-randomness" id="what-is-randomness"><h2>What is randomness?</h2></a>
<p>What does <strong>random</strong> mean? Colloquially the word can mean simply <em>unexpected</em>
or <em>unknown</em>, but we need to be a bit more precise than that. Wikipedia gives us
a more specific definition:</p>
<blockquote>
<p><strong>Randomness</strong> is the lack of pattern or predictability in events.</p>
</blockquote>
<p>We can take this further: <em>lack of pattern</em> implies there is no <em>bias</em>; in
other words, all possible values are equally likely.</p>
<p>To understand what a <em>random value</em> is, we still need a context: what pool of
numbers can our random value come from?</p>
<ul>
<li>To give a simple example, consider dice: they have values 1, 2, 3, 4, 5 and
6, and an unbiased (fair) die will make each number equally likely, with
probability ⅙th.</li>
<li>Now lets take a silly example: the natural numbers (1, 2, 3, etc.). These
numbers have no limit. So if you were to ask for an unbiased random
natural number, 1, 5, 1000, 1 million, 1 trillion — all would be equally
likely. In fact, for <em>any</em> natural number <code>k</code>, the numbers <code>1, 2, ..., k</code>
are an infinitely small fraction of all the natural numbers, which means the
chance of picking a unbiased number from this range is effectively <code>1/∞ = 0</code>.
Put another way: for <em>any</em> natural number, we expect an unbiased random
value to be bigger. This is impossible, so there cannot be any such thing as
an unbiased random natural number.</li>
<li>Another example: real numbers between 0 and 1. Real numbers include all the
fractions, irrational numbers like π and √2, and all multiples of those...
there are infinitely many possibilities, even in a small range like <code>(0, 1)</code>,
so simply saying &quot;all possibilities are equally likely&quot; is not enough.
Instead we interpret <em>lack of pattern</em> in a different way: every interval
of equal size is equally likely; for example we could subdivide the interval
<code>0,1</code> into <code>0,½</code> and <code>½,1</code> and toss a coin to decide which interval our
random sample comes from. Say we pick <code>½,1</code> we can then toss another coin to
decide between <code>½,¾</code> and <code>¾,1</code>, restricting our random value to an interval
of size <code>¼</code>. We can repeat this as many times as necessary to pick a random
value between <code>0</code> and <code>1</code> with as much precision as we want — although we
should realise that we are not choosing an <em>exact</em> value but rather just a
small interval.</li>
</ul>
<p>What we have defined (or failed to define) above are uniform random number
distributions, or simply <strong>uniform distributions</strong>. There are also non-uniform
distributions, as we shall see later. It's also worth noting here that a
uniform distribution does not imply that its samples will be <em>evenly</em> spread
(try rolling six dice: you probably won't get 1, 2, 3, 4, 5, 6).</p>
<p>To bring us back to computing, we can now define what a uniformly distributed
random value (an unbiased random value) is in several contexts:</p>
<ul>
<li><code>u32</code>: a random number between 0 and <code>u32::MAX</code> where each value is equally
likely</li>
<li><code>BigInt</code>: since this type has no upper bound, we cannot produce an unbiased
random value (it would be infinitely large, and use infinite amounts of memory)</li>
<li><code>f64</code>: we treat this as an approximation of the real numbers, and,
<em>by convention</em>, restrict to the range 0 to 1 (if not otherwise specified).
Note that this type has finite precision, so we use the coin-flipping method
above (but with random bits instead of coins) until we get as much precision
as the type can represent; however, since floating-point numbers are much
more precise close to 0 than they are near 1, we typically simplify here and
stop once we have enough precision to differentiate between 1 and the next
smallest value representable (<code>1 - ε/2</code>).</li>
</ul>
<a class="header" href="#random-data-1" id="random-data-1"><h2>Random data</h2></a>
<p>As seen above, the term &quot;random number&quot; is meaningless without context. &quot;Random
data&quot; typically means a sequence of random <em>bytes</em>, where for each byte, each of
the 256 possible values are equally likely.</p>
<p><a href="../rand/rand_core/trait.RngCore.html#tymethod.fill_bytes"><code>RngCore::fill_bytes</code></a> produces exactly this: a sequence of random bytes.</p>
<p>If a sequence of unbiased random bytes of the correct length is instead
interpreted as an integer — say a <code>u32</code> or <code>u64</code> — the result is an unbiased
integer. Since this conversion is trivial, <a href="../rand/rand_core/trait.RngCore.html#tymethod.next_u32"><code>RngCore::next_u32</code></a> and
<a href="../rand/rand_core/trait.RngCore.html#tymethod.next_u64"><code>RngCore::next_u64</code></a> are part of the same trait. (In fact the conversion is
often the other way around — algorithmic generators usually work with integers
internally, which are then converted to whichever form of random data is
required.)</p>
<a class="header" href="#random-generators" id="random-generators"><h1>Random generators</h1></a>
<p>The previous section introduced <a href="../rand/rand_core/trait.RngCore.html"><code>RngCore</code></a>, the trait which all <em>random data
sources</em> must implement. But what exactly is a random data source?</p>
<p>This section concerns theory; see also the chapter on
<a href="guide-rngs.html">random number generators</a>.</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
# extern crate rand;
# extern crate rand_pcg;
// prepare a non-deterministic random number generator:
let mut rng = rand::thread_rng();

// prepare a deterministic generator:
use rand::SeedableRng;
let mut rng = rand_pcg::Pcg32::seed_from_u64(123);
#}</code></pre></pre>
<a class="header" href="#true-random-number-generators" id="true-random-number-generators"><h2>True random number generators</h2></a>
<p>A <strong>true</strong> random number generator (TRNG) is something which produces random
numbers by observing some natural process, such as atomic decay or thermal noise.
(Whether or not these things are <em>truly</em> random or are in fact deterministic —
for example if the universe itself is a simulation — is besides the point here.
For our purposes, it is sufficient that they are not distinguishable from true
randomness.)</p>
<p>Note that these processes are often biased, thus some type of <em>debiasing</em> must
be used to yield the unbiased random data we desire.</p>
<a class="header" href="#pseudo-random-number-generators" id="pseudo-random-number-generators"><h2>Pseudo-random number generators</h2></a>
<p>CPUs are of course supposed to compute deterministically, yet it turns out they
can do a pretty good job of emulating random processes. Most pseudo-random
number generators are deterministic and can be defined by three things:</p>
<ul>
<li>some initial <em>state</em></li>
<li>a function to compute a random value from the state</li>
<li>a function to advance to the next state</li>
</ul>
<p>The fact that these are deterministic can sometimes be very useful: it allows a
simulation, randomised art work or game to be repeated exactly, producing a
result which is a function of the seed. For more on this see the
<a href="portability.html">portability</a> chapter (note that determinicity alone isn't
enough to guarantee reproducibility).</p>
<p>The other big attraction of PRNGs is their speed: some of these algorithms
require only a few CPU operations per random value, and thus can produce
random data on demand much more quickly than most TRNGs.</p>
<p>Note however that PRNGs have several limitations:</p>
<ul>
<li>They are no stronger than their seed: if the seed is known or guessable,
and the algorithm is known (or guessed), then only a small number of output
sequences are likely.</li>
<li>Since the state size is usually fixed, only a finite number of output values
are possible before the generator loops and repeats itself.</li>
<li>Several algorithms are easily predictable after seeing a few values, and
with many other algorithms it is not clear whether they could be &quot;cracked&quot;.</li>
</ul>
<a class="header" href="#cryptographically-secure-pseudo-random-number-generator" id="cryptographically-secure-pseudo-random-number-generator"><h2>Cryptographically secure pseudo-random number generator</h2></a>
<p>Cryptographically secure pseudo-random number generators (CSPRNGs) are the
subset of PRNGs which are considered secure. That is:</p>
<ul>
<li>their state is sufficiently large that a brute-force approach simply trying
all initial values is not a feasible method of finding the initial state
used to produce an observed sequence of output values,</li>
<li>and there is no other algorithm which is sufficiently better than the
brute-force method which would make it feasible to predict the next output
value.</li>
</ul>
<p>Achieving secure generation requires not only a secure algorithm (CSPRNG), but
also a secure and sufficiently large seed value (typically 256 bits), and
protection against side-channel attacks (i.e. preventing attackers from reading
the internal state).</p>
<p>Some CSPRNGs additionally satisfy a third property:</p>
<ul>
<li>a CSPRNG is backtracking resistant if it is impossible for an attacker to
calculate prior output values of the PRNG despite having discovered the
value of the current internal state (implying that all future output is
compromised).</li>
</ul>
<a class="header" href="#hardware-random-number-generator" id="hardware-random-number-generator"><h2>Hardware random number generator</h2></a>
<p>A <strong>hardware</strong> random number generator (HRNG) is theoretically an adaptor from
some TRNG to digital information. In practice, these may use a PRNG to debias
the TRNG. Even though an HRNG has some underlying TRNG, it is not guaranteed to
be secure: the TRNG itself may produce insufficient entropy (i.e. be too
predictable), or the signal amplification and debiasing process may be flawed.</p>
<p>An HRNG may be used to provide the seed for a PRNG, although usually this is not
the only way to obtain a secure seed (see the next section). An HRNG might
replace a PRNG altogether, although since we now have very fast and very strong
software PRNGs, and since software implementations are easier to verify than
hardware ones, this is often not the preferred solution.</p>
<p>Since a PRNG needs a random seed value to be secure, an HRNG may be used to
provide that seed, or even replace the need for a PRNG. However, since the goal
is usually &quot;only&quot; to produce unpredictable random values, there are acceptable
alternatives to <em>true</em> random number generators (see next section).</p>
<a class="header" href="#entropy" id="entropy"><h2>Entropy</h2></a>
<p>As noted above, for a CSPRNG to be secure, its seed value must also be secure.
The word <em>entropy</em> can be used in two ways:</p>
<ul>
<li>as a measure of the amount of unknown information in some piece of data</li>
<li>as a piece of unknown data</li>
</ul>
<p>Ideally, a random boolean or a coin flip has 1 bit of entropy, although if the
value is biased, there will be less. Shannon Entropy attempts to measure this.</p>
<p>For example, a Unix time-stamp (seconds since the start of 1970) contains both
high- and low-resolution data. This is typically a 32-bit number, but the amount
of <em>entropy</em> will depend on how precisely a hypothetical attacker can guess the
number. If an attacker can guess the number to the nearest minute, this may be
approximately 6 bits (2^6 = 64); if an attacker can guess this to the second,
this is 0 bits. <a href="../rand/rand/rngs/jitter/struct.JitterRng.html"><code>JitterRng</code></a> uses this concept to scavenge entropy without an
HRNG (but using nanosecond resolution timers and conservatively assuming only a
couple of bits entropy is available per time-stamp, after running several tests
on the timer's quality).</p>
<a class="header" href="#our-rngs" id="our-rngs"><h1>Our RNGs</h1></a>
<p>There are many kinds of RNGs, with different trade-offs. Rand provides some
convenient generators in the <a href="../rand/rand/rngs/index.html"><code>rngs</code> module</a>. Often you can just use
<a href="../rand/rand/fn.thread_rng.html"><code>thread_rng</code></a>, a function which automatically initializes an RNG in
thread-local memory and returns a reference to it. It is fast, good quality,
and (to the best of our knowledge) cryptographically secure.</p>
<p>Contents of this documentation:</p>
<ol>
<li><a href="#the-generators">The generators</a></li>
<li><a href="#performance">Performance and size</a></li>
<li><a href="#quality">Quality and cycle length</a></li>
<li><a href="#security">Security</a></li>
<li><a href="#extra-features">Extra features</a></li>
<li><a href="#further-reading">Further reading</a></li>
</ol>
<a class="header" href="#the-generators" id="the-generators"><h1>The generators</h1></a>
<a class="header" href="#basic-pseudo-random-number-generators-prngs" id="basic-pseudo-random-number-generators-prngs"><h2>Basic pseudo-random number generators (PRNGs)</h2></a>
<p>The goal of regular, non-cryptographic PRNGs is usually to find a good
balance between simplicity, quality, memory usage and performance.
Non-cryptographic generators pre-date cryptographic ones and since we now have
fast cryptographic generators, some people argue that the non-cryptographic ones
are now obsolete. They can however have some advantages: small state size, fast
initialisation and simplicity (though this is not true of all non-crypto PRNGs;
e.g. the Mersenne Twister has a large state despite being easy to predict).</p>
<p>These algorithms are very important to Monte Carlo simulations, and also
suitable for several other problems such as randomized algorithms and games,
where predictability is not an issue. (Note that it might be problematic for
betting games and multiplayer games, where a cryptographic PRNG is usually more
appropriate.)</p>
<p>The Rand project provides several non-cryptographic PRNGs. A sub-set of these
are summarised below.
You may wish to refer to the <a href="http://www.pcg-random.org/">pcg-random</a> and <a href="http://xoshiro.di.unimi.it/">xoshiro</a> websites.</p>
<table><thead><tr><th> name </th><th> full name </th><th> performance </th><th> memory </th><th> quality </th><th> period </th><th> features </th></tr></thead><tbody>
<tr><td> <a href="../rand/rand/rngs/struct.SmallRng.html"><code>SmallRng</code></a> </td><td> (unspecified) </td><td> 7 GB/s </td><td> 16 bytes </td><td> ★★★☆☆ </td><td> ≥ <code>u32</code> * 2<sup>64</sup> </td><td> not portable </td></tr>
<tr><td> <a href="../rand/rand_pcg/type.Pcg32.html"><code>Pcg32</code></a> </td><td> PCG XSH RR 64/32 (LCG) </td><td> 3 GB/s </td><td> 16 bytes </td><td> ★★★☆☆ </td><td> <code>u32</code> * 2<sup>64</sup> </td><td> — </td></tr>
<tr><td> <a href="../rand/rand_pcg/type.Pcg64.html"><code>Pcg64</code></a> </td><td> PCG XSL 128/64 (LCG) </td><td> 4 GB/s </td><td> 32 bytes </td><td> ★★★★☆ </td><td> <code>u64</code> * 2<sup>128</sup> </td><td> — </td></tr>
<tr><td> <a href="../rand/rand_pcg/type.Pcg64Mcg.html"><code>Pcg64Mcg</code></a> </td><td> PCG XSL 128/64 (MCG) </td><td> 7 GB/s </td><td> 16 bytes </td><td> ★★★☆☆ </td><td> <code>u64</code> * 2<sup>126</sup> </td><td> — </td></tr>
<tr><td> <a href="../rand/rand_xorshift/struct.XorShiftRng.html"><code>XorShiftRng</code></a> </td><td> Xorshift 32/128 </td><td> 5 GB/s </td><td> 16 bytes </td><td> ★☆☆☆☆ </td><td> <code>u32</code> * 2<sup>128</sup> - 1 </td><td> — </td></tr>
<tr><td> <a href="../rand/rand_xoshiro/struct.Xoshiro256StarStar.html"><code>Xoshiro256StarStar</code></a> </td><td> Xoshiro256** </td><td> 7 GB/s </td><td> 32 bytes </td><td> ★★★☆☆ </td><td> <code>u64</code> * 2<sup>256</sup> - 1 </td><td> jump-ahead </td></tr>
<tr><td> <a href="../rand/rand_xoshiro/struct.Xoshiro256Plus.html"><code>Xoshiro256Plus</code></a> </td><td> Xoshiro256+ </td><td> 8 GB/s </td><td> 32 bytes </td><td> ★★☆☆☆ </td><td> <code>u64</code> * 2<sup>256</sup> - 1 </td><td> jump-ahead </td></tr>
<tr><td> <a href="../rand/rand_xoshiro/struct.SplitMix64.html"><code>SplitMix64</code></a> </td><td> splitmix64 </td><td> 8 GB/s </td><td> 8 bytes </td><td> ★☆☆☆☆ </td><td> <code>u64</code> * 2<sup>64</sup> </td><td> — </td></tr>
<tr><td> <a href="../rand/rand/rngs/mock/struct.StepRng.html"><code>StepRng</code></a> </td><td> counter </td><td> 51 GB/s </td><td> 16 bytes </td><td> ☆☆☆☆☆ </td><td> <code>u64</code> * 2<sup>64</sup> </td><td> — </td></tr>
</tbody></table>
<p>Here, performance is measured roughly for <code>u64</code> outputs on a 3.4GHz Haswell CPU
(note that this will vary significantly by application; in general cryptographic
RNGs do better with byte sequence output). Quality ratings are
based on theory and observable defects, roughly as follows:</p>
<ul>
<li>★☆☆☆☆ = suitable for simple applications but with significant flaws</li>
<li>★★☆☆☆ = good performance in most tests, some issues</li>
<li>★★★☆☆ = good performance and theory, no major issues</li>
<li>★★★★☆ = no observable issues and not trivial to predict (but not
recommended for security)</li>
<li>★★★★★ = cryptographic quality</li>
</ul>
<a class="header" href="#cryptographically-secure-pseudo-random-number-generators-csprngs" id="cryptographically-secure-pseudo-random-number-generators-csprngs"><h2>Cryptographically secure pseudo-random number generators (CSPRNGs)</h2></a>
<p>CSPRNGs have much higher requirements than basic PRNGs. The primary
consideration is security. Performance and simplicity are also important,
but in general CSPRNGs are more complex and slower than regular PRNGs.
Quality is no longer a concern, as it is a requirement for a
CSPRNG that the output is basically indistinguishable from true randomness
since any bias or correlation makes the output more predictable.</p>
<p>There is a close relationship between CSPRNGs and cryptographic ciphers.
Any block cipher can be turned into a CSPRNG by encrypting a counter. Stream
ciphers are basically a CSPRNG and a combining operation, usually XOR. This
means that we can easily use any stream cipher as a CSPRNG.</p>
<p>This library provides the following CSPRNGs. We can make no guarantees
of any security claims. This table omits the &quot;quality&quot; column from the previous
table since CSPRNGs may not have observable defects.</p>
<table><thead><tr><th> name </th><th> full name </th><th>  performance </th><th> initialization </th><th> memory </th><th> security (predictability) </th><th> forward secrecy </th></tr></thead><tbody>
<tr><td> <a href="../rand/rand/rngs/struct.StdRng.html"><code>StdRng</code></a> </td><td> (unspecified) </td><td> 1.5 GB/s </td><td> fast </td><td> 136 bytes </td><td> widely trusted </td><td> no </td></tr>
<tr><td> <a href="../rand/rand_chacha/struct.ChaCha20Rng.html"><code>ChaCha20Rng</code></a> </td><td> ChaCha20 </td><td> 1.8 GB/s </td><td> fast </td><td> 136 bytes </td><td> <a href="https://tools.ietf.org/html/rfc7539#section-1">rigorously analysed</a> </td><td> no </td></tr>
<tr><td> <a href="../rand/rand_chacha/struct.ChaCha8Rng.html"><code>ChaCha8Rng</code></a> </td><td> ChaCha8 </td><td> 2.2 GB/s </td><td> fast </td><td> 136 bytes </td><td> small security margin </td><td> no </td></tr>
<tr><td> <a href="../rand/rand_hc/struct.Hc128Rng.html"><code>Hc128Rng</code></a> </td><td> HC-128 </td><td> 2.1 GB/s </td><td> slow </td><td> 4176 bytes </td><td> <a href="http://www.ecrypt.eu.org/stream/">recommended by eSTREAM</a> </td><td> no </td></tr>
<tr><td> <a href="../rand/rand_isaac/isaac/struct.IsaacRng.html"><code>IsaacRng</code></a> </td><td> ISAAC </td><td> 1.1 GB/s </td><td> slow </td><td> 2072 bytes </td><td> <a href="https://burtleburtle.net/bob/rand/isaacafa.html">unknown</a> </td><td> unknown </td></tr>
<tr><td> <a href="../rand/rand_isaac/isaac64/struct.Isaac64Rng.html"><code>Isaac64Rng</code></a> </td><td> ISAAC-64 </td><td> 2.2 GB/s </td><td> slow </td><td> 4136 bytes</td><td> unknown </td><td> unknown </td></tr>
</tbody></table>
<p>It should be noted that the ISAAC generators are only included for
historical reasons, they have been with the Rust language since the very
beginning. They have good quality output and no attacks are known, but have
received little attention from cryptography experts.</p>
<a class="header" href="#notes-on-generators" id="notes-on-generators"><h1>Notes on generators</h1></a>
<a class="header" href="#performance" id="performance"><h2>Performance</h2></a>
<p>First it has to be said most PRNGs are very fast, and will rarely be a
performance bottleneck.</p>
<p>Performance of basic PRNGs is a bit of a subtle thing. It depends a lot on
the CPU architecture (32 vs. 64 bits), inlining, and also on the number of
available registers. This often causes the performance to be affected by
surrounding code due to inlining and other usage of registers.</p>
<p>When choosing a PRNG for performance it is important to benchmark your own
application due to interactions between PRNGs and surrounding code and
dependence on the CPU architecture as well as the impact of the size of
data requested. Because of all this, we do not include performance numbers
here but merely a qualitative rating.</p>
<p>CSPRNGs are a little different in that they typically generate a block of
output in a cache, and pull outputs from the cache. This allows them to have
good amortised performance, and reduces or completely removes the influence
of surrounding code on the CSPRNG performance.</p>
<a class="header" href="#worst-case-performance" id="worst-case-performance"><h3>Worst-case performance</h3></a>
<p>Simple PRNGs typically produce each random value on demand. In contrast, CSPRNGs
usually produce a whole block at once, then read from this cache until it is
exhausted, giving them much less consistent performance when drawing small
quantities of random data.</p>
<a class="header" href="#memory-usage" id="memory-usage"><h3>Memory usage</h3></a>
<p>Simple PRNGs often use very little memory, commonly only a few words, where
a <em>word</em> is usually either <code>u32</code> or <code>u64</code>. This is not true for all
non-cryptographic PRNGs however, for example the historically popular
Mersenne Twister MT19937 algorithm requires 2.5 kB of state.</p>
<p>CSPRNGs typically require more memory; since the seed size is recommended
to be at least 192 bits and some more may be required for the algorithm,
256 bits would be approximately the minimum secure size. In practice,
CSPRNGs tend to use quite a bit more, <a href="../rand/rand_chacha/struct.ChaChaRng.html"><code>ChaChaRng</code></a> is relatively small with
136 bytes of state.</p>
<a class="header" href="#initialization-time" id="initialization-time"><h3>Initialization time</h3></a>
<p>The time required to initialize new generators varies significantly. Many
simple PRNGs and even some cryptographic ones (including <a href="../rand/rand_chacha/struct.ChaChaRng.html"><code>ChaChaRng</code></a>)
only need to copy the seed value and some constants into their state, and
thus can be constructed very quickly. In contrast, CSPRNGs with large state
require an expensive key-expansion.</p>
<a class="header" href="#quality" id="quality"><h2>Quality</h2></a>
<p>Many basic PRNGs are not much more than a couple of bitwise and arithmetic
operations. Their simplicity gives good performance, but also means there
are small regularities hidden in the generated random number stream.</p>
<p>How much do those hidden regularities matter? That is hard to say, and
depends on how the RNG gets used. If there happen to be correlations between
the random numbers and the algorithm they are used in, the results can be
wrong or misleading.</p>
<p>A random number generator can be considered good if it gives the correct
results in as many applications as possible. The quality of PRNG
algorithms can be evaluated to some extend analytically, to determine the
cycle length and to rule out some correlations. Then there are empirical
test suites designed to test how well a PRNG performs on a wide range of
possible uses, the latest and most complete of which are <a href="http://simul.iro.umontreal.ca/testu01/tu01.html">TestU01</a> and
<a href="http://pracrand.sourceforge.net/">PractRand</a>.</p>
<p>CSPRNGs tend to be more complex, and have an explicit requirement to be
unpredictable. This implies there must be no obvious correlations between
output values.</p>
<a class="header" href="#quality-stars" id="quality-stars"><h3>Quality stars:</h3></a>
<p>PRNGs with 3 stars or more should be good enough for most non-crypto
applications. 1 or 2 stars may be good enough for typical apps and games, but do
not work well with all algorithms.</p>
<a class="header" href="#period" id="period"><h3>Period</h3></a>
<p>The <em>period</em> or <em>cycle length</em> of a PRNG is the number of values that can be
generated after which it starts repeating the same random number stream.
Many PRNGs have a fixed-size period, but for some only an expected average
cycle length can be given, where the exact length depends on the seed.</p>
<p>On today's hardware, even a fast RNG with a cycle length of <em>only</em>
2<sup>64</sup> can be used sequentially for centuries before cycling. However,
this is not the case for parallel applications. We recommend a period of
2<sup>128</sup> or more, which most modern PRNGs satisfy. Alternatively a PRNG
with shorter period but support for multiple streams may be chosen. There are
two reasons for this, as follows.</p>
<p>If we see the entire period of an RNG as one long random number stream,
every independently seeded RNG returns a slice of that stream. When multiple
RNG are seeded randomly, there is an increasingly large chance to end up
with a partially overlapping slice of the stream.</p>
<p>If the period of the RNG is 2<sup>128</sup>, and an application consumes
2<sup>48</sup> values, it then takes about 2<sup>32</sup> random
initializations to have a chance of 1 in a million to repeat part of an
already used stream. This seems good enough for common usage of
non-cryptographic generators, hence the recommendation of at least
2<sup>128</sup>. As an estimate, the chance of any overlap in a period of
size <code>p</code> with <code>n</code> independent seeds and <code>u</code> values used per seed is
approximately <code>1 - e^(-u * n^2 / (2 * p))</code>.</p>
<p>Further, it is not recommended to use the full period of an RNG. Many
PRNGs have a property called <em>k-dimensional equidistribution</em>, meaning that
for values of some size (potentially larger than the output size), all
possible values are produced the same number of times over the generator's
period. This is not a property of true randomness. This is known as the
generalized birthday problem, see the <a href="http://www.pcg-random.org/pdf/hmc-cs-2014-0905.pdf">PCG paper</a> for a good explanation.
This results in a noticable bias on output after generating more values
than the square root of the period (after 2<sup>64</sup> values for a
period of 2<sup>128</sup>).</p>
<a class="header" href="#security" id="security"><h2>Security</h2></a>
<a class="header" href="#predictability" id="predictability"><h3>Predictability</h3></a>
<p>From the context of any PRNG, one can ask the question <em>given some previous
output from the PRNG, is it possible to predict the next output value?</em>
This is an important property in any situation where there might be an
adversary.</p>
<p>Regular PRNGs tend to be predictable, although with varying difficulty. In
some cases prediction is trivial, for example plain Xorshift outputs part of
its state without mutation, and prediction is as simple as seeding a new
Xorshift generator from four <code>u32</code> outputs. Other generators, like
<a href="http://www.pcg-random.org/predictability.html">PCG</a> and truncated Xorshift*
are harder to predict, but not outside the realm of common mathematics and a
desktop PC.</p>
<p>The basic security that CSPRNGs must provide is the infeasibility to predict
output. This requirement is formalized as the <a href="https://en.wikipedia.org/wiki/Next-bit_test">next-bit test</a>; this is
roughly stated as: given the first <em>k</em> bits of a random sequence, the
sequence satisfies the next-bit test if there is no algorithm able to
predict the next bit using reasonable computing power.</p>
<p>A further security that <em>some</em> CSPRNGs provide is forward secrecy:
in the event that the CSPRNGs state is revealed at some point, it must be
infeasible to reconstruct previous states or output. Note that many CSPRNGs
<em>do not</em> have forward secrecy in their usual formulations.</p>
<p>Verifying security claims of an algorithm is a <em>hard problem</em>, and we are not
able to provide any guarantees of the security of algorithms used or recommended
by this project. We refer you to the <a href="https://www.nist.gov/">NIST</a> institute and <a href="http://www.ecrypt.eu.org/">ECRYPT</a> network
for recommendations.</p>
<a class="header" href="#state-and-seeding" id="state-and-seeding"><h3>State and seeding</h3></a>
<p>It is worth noting that a CSPRNG's security relies absolutely on being
seeded with a secure random key. Should the key be known or guessable, all
output of the CSPRNG is easy to guess. This implies that the seed should
come from a trusted source; usually either the OS or another CSPRNG. Our
seeding helper trait, <a href="../rand/rand/trait.FromEntropy.html"><code>FromEntropy</code></a>, and the source it uses
(<a href="../rand/rand/rngs/struct.EntropyRng.html"><code>EntropyRng</code></a>), should be secure. Additionally, <a href="../rand/rand/rngs/struct.ThreadRng.html"><code>ThreadRng</code></a> is a CSPRNG,
thus it is acceptable to seed from this (although for security applications
fresh/external entropy should be preferred).</p>
<p>Further, it should be obvious that the internal state of a CSPRNG must be
kept secret. With that in mind, our implementations do not provide direct
access to most of their internal state, and <code>Debug</code> implementations do not
print any internal state. This does not fully protect CSPRNG state; code
within the same process may read this memory (and we allow cloning and
serialisation of CSPRNGs for convenience). Further, a running process may be
forked by the operating system, which may leave both processes with a copy
of the same generator.</p>
<a class="header" href="#not-a-crypto-library" id="not-a-crypto-library"><h3>Not a crypto library</h3></a>
<p>It should be emphasised that this is not a cryptography library; although
Rand does take some measures to provide secure random numbers, it does not
necessarily take all recommended measures. Further, cryptographic processes
such as encryption and authentication are complex and must be implemented
very carefully to avoid flaws and resist known attacks. It is therefore
recommended to use specialized libraries where possible, for example
<a href="https://crates.io/crates/openssl">openssl</a>, <a href="https://crates.io/crates/ring">ring</a> and the <a href="https://github.com/RustCrypto">RustCrypto libraries</a>.</p>
<a class="header" href="#extra-features" id="extra-features"><h2>Extra features</h2></a>
<p>Some PRNGs may provide extra features, like:</p>
<ul>
<li>Support for multiple streams, which can help with parallel tasks.</li>
<li>The ability to jump or seek around in the random number stream;
with a large period this can be used as an alternative to streams.</li>
</ul>
<a class="header" href="#further-reading" id="further-reading"><h2>Further reading</h2></a>
<p>There is quite a lot that can be said about PRNGs. The <a href="http://www.pcg-random.org/pdf/hmc-cs-2014-0905.pdf">PCG paper</a> is very
approachable and explains more concepts.</p>
<p>Another good paper about RNG quality is
<a href="http://random.mat.sbg.ac.at/results/peter/A19final.pdf">&quot;Good random number generators are (not so) easy to find&quot;</a> by P. Hellekalek.</p>
<a class="header" href="#random-values" id="random-values"><h1>Random values</h1></a>
<p>Now that we have a way of producing random data, how can we convert it to the
type of value we want?</p>
<p>This is a trick question: we need to know both the <em>range</em> we want and the type
of <em>distribution</em> of this value (which is what the <a href="guide-dist.html"><code>next</code></a> section
is all about).</p>
<p>For convenience, all generators automatically implement the <a href="../rand/rand/trait.Rng.html"><code>Rng</code></a> trait,
which provides short-cuts to a few ways of generating values. This has several
convenience functions for producing uniformly distributed values:</p>
<ul>
<li><a href="../rand/rand/trait.Rng.html#method.gen"><code>gen</code></a> generates an unbiased random value from a range appropriate for the
type. For integers this is normally the full representable range
(e.g. from <code>0u32</code> to <code>std::u32::MAX</code>), for floats this is between 0 and 1,
and some other types are supported, including arrays and tuples.
More on this in the <a href="guide-dist.html#uniform-distributions">next section</a>.</li>
<li><a href="../rand/rand/trait.Rng.html#method.gen_range"><code>gen_range</code></a> generates an unbiased random value with given bounds
<code>low</code> (inclusive) and <code>high</code> (exclusive)</li>
<li><a href="../rand/rand/trait.Rng.html#method.fill"><code>fill</code></a> and <a href="../rand/rand/trait.Rng.html#method.try_fill"><code>try_fill</code></a> are optimised functions for filling any byte or
integer slice with random values</li>
</ul>
<p>It also has convenience functions for producing non-uniform boolean values:</p>
<ul>
<li><a href="../rand/rand/trait.Rng.html#method.gen_bool"><code>gen_bool</code></a> generates a boolean with the given probability</li>
<li><a href="../rand/rand/trait.Rng.html#method.gen_ratio"><code>gen_ratio</code></a> also generates a boolean, where the probability is defined
via a fraction</li>
</ul>
<p>Finally, it has a function to sample from arbitrary distributions:</p>
<ul>
<li><a href="../rand/rand/trait.Rng.html#method.sample"><code>sample</code></a> samples directly from some <a href="guide-dist.html">distribution</a></li>
</ul>
<p>Examples:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
# extern crate rand;
use rand::Rng;
let mut rng = rand::thread_rng();

// an unbiased integer over the entire range:
let i: i32 = rng.gen();

// a uniformly distributed value between 0 and 1:
let x: f64 = rng.gen();

// simulate rolling a die:
let roll = rng.gen_range(1, 7);
#}</code></pre></pre>
<p>Additionally, the <a href="../rand/rand/fn.random.htm"><code>random</code></a> function is a short-cut to <a href="../rand/rand/trait.Rng.html#method.gen"><code>gen</code></a> on the <a href="../rand/rand/fn.thread_rng.html"><code>thread_rng</code></a>:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
if rand::random() {
    println!(&quot;we got lucky!&quot;);
}
#}</code></pre></pre>
<a class="header" href="#random-distributions" id="random-distributions"><h1>Random distributions</h1></a>
<p>For maximum flexibility when producing random values, we define the
<a href="../rand/rand/distributions/trait.Distribution.html"><code>Distribution</code></a> trait:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
// a producer of data of type T:
pub trait Distribution&lt;T&gt; {
    // the key function:
    fn sample&lt;R: Rng + ?Sized&gt;(&amp;self, rng: &amp;mut R) -&gt; T;

    // a convenience function defined using sample:
    fn sample_iter&lt;'a, R&gt;(&amp;'a self, rng: &amp;'a mut R) -&gt; DistIter&lt;'a, Self, R, T&gt;
    where
        Self: Sized,
        R: Rng,
    { ... }
}
#}</code></pre></pre>
<p>Rand provides implementations of many different distributions; for the full
list see the <a href="../rand/rand/distributions/index.html"><code>distributions</code></a> module; the most common are highlighted below.</p>
<a class="header" href="#uniform-distributions" id="uniform-distributions"><h2>Uniform distributions</h2></a>
<p>The most obvious type of distribution is the one we already discussed: one
without pattern, where each value or range of values is equally likely. This is
known as <em>uniform</em>.</p>
<p>Rand actually has several variants of this:</p>
<ul>
<li><a href="../rand/rand/distributions/struct.Standard.html"><code>Standard</code></a> requires no parameters and produces uniformly distributed
values over the entire range of the output type (for <code>bool</code> and integers)
or over the range from 0 to 1 (for floats) or over valid Unicode code
points. It also has extensions to tuples, array types and <code>Option</code>.</li>
<li><a href="../rand/rand/distributions/struct.Uniform.html"><code>Uniform</code></a> is parametrised with <code>low</code> and <code>high</code> points, and produces
values uniformly distributed within this range.</li>
<li><a href="../rand/rand/distributions/struct.Alphanumeric.html"><code>Alphanumeric</code></a> is uniform over the values <code>0-9A-Za-z</code></li>
<li><a href="../rand/rand/distributions/struct.Open01.html"><code>Open01</code></a> and <a href="../rand/rand/distributions/struct.OpenClosed01.html"><code>OpenClosed01</code></a> are variations of <a href="../rand/rand/distributions/struct.Standard.html"><code>Standard</code></a> for floating
point numbers between 0 and 1 (partially) exclusive of end points.</li>
</ul>
<p>For convenience, <a href="../rand/rand/trait.Rng.html#method.gen"><code>Rng::gen</code></a> and <a href="../rand/rand/fn.random.html"><code>random</code></a> are short-cuts to <a href="../rand/rand/distributions/struct.Standard.html"><code>Standard</code></a>,
and <a href="../rand/rand/trait.Rng.html#method.gen_range"><code>Rng::gen_range</code></a> is a short-cut to <a href="../rand/rand/distributions/struct.Uniform.html"><code>Uniform</code></a>, allowing things like:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
# extern crate rand;
# use rand::prelude::*;
let mut rng = thread_rng();
let coord: (f64, f64) = rng.gen();
let die_roll = rng.gen_range(1, 7);
#}</code></pre></pre>
<a class="header" href="#more-continuous-distributions" id="more-continuous-distributions"><h2>More continuous distributions</h2></a>
<p>The exponential distribution, <a href="../rand/rand/distributions/struct.Exp.html"><code>Exp</code></a>, simulates time until decay, assuming a
fixed rate of decay (i.e. exponential decay).</p>
<p>The <a href="../rand/rand/distributions/struct.Normal.html"><code>Normal</code></a> distribution (also known as Gaussian) simulates sampling from
the Normal distribution (&quot;Bell curve&quot;) with the given mean and standard
deviation. The <a href="../rand/rand/distributions/struct.LogNormal.html"><code>LogNormal</code></a> is related: for sample <code>X</code> from the log-normal
distribution, <code>log(X)</code> is normally distributed; this &quot;skews&quot; the normal
distribution to avoid negative values and to have a long positive tail.</p>
<p>The <a href="../rand/rand/distributions/struct.UnitCircle.html"><code>UnitCircle</code></a> and <a href="../rand/rand/distributions/struct.UnitSphereSurface.html"><code>UnitSphereSurface</code></a> distributions simulate uniform
sampling from the edge of a circle or surface of a sphere.</p>
<p>The <a href="../rand/rand/distributions/struct.Cauchy.html"><code>Cauchy</code></a> distribution (also known as the Lorentz distribution) is the
distribution of the x-intercept of a ray from point <code>(x0, γ)</code> with uniformly
distributed angle.</p>
<p>The <a href="../rand/rand/distributions/struct.Beta.html"><code>Beta</code></a> distribution is a two-parameter probability distribution, whose
output values lie between 0 and 1. The <a href="../rand/rand/distributions/struct.Dirichlet.html"><code>Dirichlet</code></a> distribution is a
generalisation to any positive number of parameters.</p>
<a class="header" href="#discrete-distributions" id="discrete-distributions"><h2>Discrete distributions</h2></a>
<p>The <a href="../rand/rand/distributions/struct.Bernoulli.html"><code>Bernoulli</code></a> distribution is very simple: given a probability <code>p</code> (or a
ratio <code>num / denom</code>), a boolean value is produced with the given probability
of being <code>true</code> (simulating a trial with probability <code>p</code> of success).</p>
<p>For convenience, <a href="../rand/rand/trait.Rng.html#method.gen_bool"><code>Rng::gen_bool</code></a> and <a href="../rand/rand/trait.Rng.html#method.gen_ratio"><code>Rng::gen_ratio</code></a> are short-cuts to <a href="../rand/rand/distributions/struct.Bernoulli.html"><code>Bernoulli</code></a>.</p>
<p>The <a href="../rand/rand/distributions/struct.Binomial.html"><code>Binomial</code></a> distribution is related: given a probability <code>p</code> and a number
<code>n</code>, this distribution simulates running <code>n</code> Bernoulli trials and tells you the
number which were successful.</p>
<p>The <a href="../rand/rand/distributions/struct.Poisson.html"><code>Poisson</code></a> distribution expresses the expected number of events occurring
within a fixed interval, given that events occur with fixed rate λ.</p>
<a class="header" href="#weighted-sampling" id="weighted-sampling"><h2>Weighted sampling</h2></a>
<p>Finally, <a href="../rand/rand/distributions/weighted/struct.WeightedIndex.html"><code>WeightedIndex</code></a> is a discrete distribution sampling from a finite
selection of choices each with given weight.</p>
<a class="header" href="#sequences" id="sequences"><h1>Sequences</h1></a>
<p>Rand implements a few common random operations on sequences via the
<a href="../rand/rand/seq/trait.IteratorRandom.html"><code>IteratorRandom</code></a> and <a href="../rand/rand/seq/trait.SliceRandom.html"><code>SliceRandom</code></a> traits:</p>
<ul>
<li><code>choose</code> one element uniformly from the sequence</li>
<li><code>choose_multiple</code> elements uniformly without replacement</li>
<li><code>choose_weighted</code> — choose an element non-uniformly by use of a defined
weight from a slice (also see the <a href="../rand/rand/distributions/struct.WeightedIndex.html"><code>WeightedIndex</code></a> distribution)</li>
<li><code>shuffle</code> a slice</li>
<li><code>partial_shuffle</code> a slice, effectively extracting <code>amount</code> elements in
random order</li>
</ul>
<a class="header" href="#error-handling" id="error-handling"><h1>Error handling</h1></a>
<p>Error handling in Rand is a compromise between simplicity and necessity.
Most RNGs and sampling functions will never produce errors, and making these
able to handle errors would add significant overhead (to code complexity
and ergonomics of usage at least, and potentially also performance,
depending on the approach).
However, external RNGs can fail, and being able to handle this is important.</p>
<p>It has therefore been decided that <em>most</em> methods should not return a
<code>Result</code> type, but with a few important exceptions, namely:</p>
<ul>
<li><a href="../rand/rand/trait.Rng.html#method.try_fill"><code>Rng::try_fill</code></a></li>
<li><a href="../rand/rand_core/trait.RngCore.html#tymethod.try_fill_bytes"><code>RngCore::try_fill_bytes</code></a></li>
<li><a href="../rand/rand_core/trait.SeedableRng.html#method.from_rng"><code>SeedableRng::from_rng</code></a></li>
</ul>
<p>Most functions consuming random values will not attempt any error handling, and
reduce to calls to <a href="../rand/rand_core/trait.RngCore.html"><code>RngCore</code></a>'s &quot;infallible&quot; methods. Since most RNGs cannot
fail anyway this is usually not a problem, but the few generators which can may
be forced to fail in this case:</p>
<ul>
<li><a href="../rand/rand/rngs/struct.OsRng.html"><code>OsRng</code></a> interfaces with the Operating System's generator; in rare cases
this may fail as &quot;not ready&quot; or simply &quot;unavailable&quot;.</li>
<li><a href="../rand/rand/rngs/struct.JitterRng.html"><code>JitterRng</code></a> is a generator based on timer jitter; if the timer does not
appear to be capable of sufficient precision or is too predictable, this
will fail.</li>
<li><a href="../rand/rand/rngs/struct.EntropyRng.html"><code>EntropyRng</code></a> is an abstraction over the above, falling back to the next
option when the first fails but ultimately failing if all sources fail</li>
<li><a href="../rand/rand/fn.thread_rng.html"><code>thread_rng</code></a> seeds itself via <a href="../rand/rand/rngs/struct.EntropyRng.html"><code>EntropyRng</code></a>, thus can potentially fail
on its first use on each thread (though it never fails after the first use)</li>
<li><a href="../rand/rand/rngs/adapter/struct.ReadRng.html"><code>ReadRng</code></a> tries to read data from its source but fails when the stream
ends or errors (though it retries on interrupt).</li>
</ul>
<a class="header" href="#portability" id="portability"><h1>Portability</h1></a>
<a class="header" href="#definitions" id="definitions"><h2>Definitions</h2></a>
<p>Given fixed inputs, all items (should) fall into one of three categories:</p>
<ul>
<li>Output is non-deterministic, thus never reproducible</li>
<li>Output is deterministic, but not considered portable</li>
<li>Output is deterministic and portable</li>
</ul>
<p>In general, functionality is considered deterministic and portable <em>unless</em>
it is clearly non-deterministic (e.g. <code>getrandom</code>, <code>ThreadRng</code>) <em>or</em> it is
documented as being unportable (e.g. <code>StdRng</code>, <code>SmallRng</code>).</p>
<a class="header" href="#crate-versions" id="crate-versions"><h2>Crate versions</h2></a>
<p>We try to follow <a href="https://docs.npmjs.com/misc/semver">semver rules</a> regarding
API-breaking changes and <code>MAJOR.MINOR.PATCH</code> versions:</p>
<ul>
<li>New <em>patch</em> versions should not include API-breaking changes or major new
features</li>
<li>Before 1.0, <em>minor</em> versions may include API breaking changes. After 1.0
they should not.</li>
</ul>
<p>Additionally, we must also consider <em>value-breaking changes</em> and <em>portability</em>.
When given fixed inputs,</p>
<ul>
<li>For non-deterministic items, implementations may change in any release</li>
<li>For deterministic unportable items, output should be preserved in patch
releases, but may change in any minor release (including after 1.0)</li>
<li>For portable items, any change of output across versions is considered
equivalent to an API breaking change.</li>
</ul>
<a class="header" href="#portability-of-usize" id="portability-of-usize"><h2>Portability of usize</h2></a>
<p>There is unfortunately one non-portable item baked into the heart of the Rust
language: <code>usize</code> (and <code>isize</code>). For example, the size of an empty
<code>Vec</code> will differ on 32-bit and 64-bit targets. For most purposes this is not an
issue, but when it comes to generating random numbers in a portable manner
it does matter.</p>
<p>A simple rule follows: if portability is required, <em>never</em> sample a <code>usize</code> or
<code>isize</code> value directly.</p>
<p>Within Rand we adhere to this rule whenever possible. All sequence-releated
code requiring a bounded <code>usize</code> value will sample a <code>u32</code> value unless the
upper bound exceeds <code>u32::MAX</code>.
(Note that this actually improves benchmark performance in many cases.)</p>
<a class="header" href="#portability-of-floats" id="portability-of-floats"><h2>Portability of floats</h2></a>
<p>The results of floating point arithmetic depend on rounding modes and
implementation details. Especially the results of transcendental functions vary
from platform to platform. Due to this, the distributions in <code>rand_distr</code> are
not always portable for <code>f32</code> and <code>f64</code>. However, we strive to make them as
portable as possible.</p>
<a class="header" href="#updating" id="updating"><h1>Updating</h1></a>
<p>This guide is intended to facilitate upgrading to the next minor or major
version of Rand. Note that updating to the next patch version (e.g. 0.5.1 to
0.5.2) should never require code changes.</p>
<p>This guide gives a few more details than the <a href="https://github.com/rust-random/rand/blob/master/CHANGELOG.md">changelog</a>, in particular giving
guidance on how to use new features and migrate away from old ones.</p>
<a class="header" href="#updating-to-05" id="updating-to-05"><h1>Updating to 0.5</h1></a>
<p>The 0.5 release has quite significant changes over the 0.4 release; as such,
it may be worth reading through the following coverage of breaking changes.
This release also contains many optimisations, which are not detailed below.</p>
<a class="header" href="#crates-1" id="crates-1"><h2>Crates</h2></a>
<p>We have a new crate: <code>rand_core</code>! This crate houses some important traits,
<code>RngCore</code>, <code>BlockRngCore</code>, <code>SeedableRng</code> and <code>CryptoRng</code>, the error types, as
well as two modules with helpers for implementations: <code>le</code> and <code>impls</code>. It is
recommended that implementations of generators use the <code>rand_core</code> crate while
other users use only the <code>rand</code> crate, which re-exports most parts of <code>rand_core</code>.</p>
<p>The <code>rand_derive</code> crate has been deprecated due to very low usage and
deprecation of <code>Rand</code>.</p>
<a class="header" href="#features" id="features"><h2>Features</h2></a>
<p>Several new Cargo feature flags have been added:</p>
<ul>
<li><code>alloc</code>, used without <code>std</code>, allows use of <code>Box</code> and <code>Vec</code></li>
<li><code>serde1</code> adds serialization support to some PRNGs</li>
<li><code>log</code> adds logging in a few places (primarily to <code>OsRng</code> and <code>JitterRng</code>)</li>
</ul>
<a class="header" href="#rng-and-friends-core-traits" id="rng-and-friends-core-traits"><h2><code>Rng</code> and friends (core traits)</h2></a>
<p><code>Rng</code> trait has been split into two traits, a &quot;back end&quot; <code>RngCore</code> (implemented
by generators) and a &quot;front end&quot; <code>Rng</code> implementing all the convenient extension
methods.</p>
<p>Implementations of generators must <code>impl RngCore</code> instead. Usage of <code>rand_core</code>
for implementations is encouraged; the <code>rand_core::{le, impls}</code> modules may
prove useful.</p>
<p>Users of <code>Rng</code> <em>who don't need to implement it</em> won't need to make so many
changes; often users can forget about <code>RngCore</code> and only import <code>Rng</code>. Instead
of <code>RngCore::next_u32()</code> / <code>next_u64()</code> users should prefer <code>Rng::gen()</code>, and
instead of <code>RngCore::fill_bytes(dest)</code>, <code>Rng::fill(dest)</code> can be used.</p>
<a class="header" href="#rng--rngcore-methods" id="rng--rngcore-methods"><h3><code>Rng</code> / <code>RngCore</code> methods</h3></a>
<p>To allow error handling from fallible sources (e.g. <code>OsRng</code>), a new
<code>RngCore::try_fill_bytes</code> method has been added; for example <code>EntropyRng</code> uses
this mechanism to fall back to <code>JitterRng</code> if <code>OsRng</code> fails, and various
handlers produce better error messages.
As before, the other methods will panic on failure, but since these are usually
used with algorithmic generators which are usually infallible, this is
considered an appropriate compromise.</p>
<p>A few methods from the old <code>Rng</code> have been removed or deprecated:</p>
<ul>
<li><code>next_f32</code> and <code>next_f64</code>; these are no longer implementable by generators;
use <code>gen</code> instead</li>
<li><code>gen_iter</code>; users may instead use standard iterators with closures:
<code>::std::iter::repeat(()).map(|()| rng.gen())</code></li>
<li><code>gen_ascii_chars</code>; use <code>repeat</code> as above and <code>rng.sample(Alphanumeric)</code></li>
<li><code>gen_weighted_bool(n)</code>; use <code>gen_bool(1.0 / n)</code> instead</li>
</ul>
<p><code>Rng</code> has a few new methods:</p>
<ul>
<li><code>sample(distr)</code> is a shortcut for <code>distr.sample(rng)</code> for any <code>Distribution</code></li>
<li><code>gen_bool(p)</code> generates a boolean with probability <code>p</code> of being true</li>
<li><code>fill</code> and <code>try_fill</code>, corresponding to <code>fill_bytes</code> and <code>try_fill_bytes</code>
respectively (i.e. the only difference is error handling); these can fill
and integer slice / array directly, and provide better performance
than <code>gen()</code></li>
</ul>
<a class="header" href="#constructing-prngs" id="constructing-prngs"><h3>Constructing PRNGs</h3></a>
<a class="header" href="#new-randomly-initialised-prngs" id="new-randomly-initialised-prngs"><h4>New randomly-initialised PRNGs</h4></a>
<p>A new trait has been added: <code>FromEntropy</code>. This is automatically implemented for
any type supporting <code>SeedableRng</code>, and provides construction from fresh, strong
entropy:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
use rand::{ChaChaRng, FromEntropy};

let mut rng = ChaChaRng::from_entropy();
#}</code></pre></pre>
<a class="header" href="#seeding-prngs" id="seeding-prngs"><h4>Seeding PRNGs</h4></a>
<p>The <code>SeedableRng</code> trait has been modified to include the seed type via an
associated type (<code>SeedableRng::Seed</code>) instead of a template parameter
(<code>SeedableRng&lt;Seed&gt;</code>). Additionally, all PRNGs now seed from a byte-array
(<code>[u8; N]</code> for some fixed N). This allows generic handling of PRNG seeding
which was not previously possible.</p>
<p>PRNGs are no longer constructed from other PRNGs via <code>Rand</code> support / <code>gen()</code>,
but through <code>SeedableRng::from_rng</code>, which allows error handling and is
intentionally explicit.</p>
<p><code>SeedableRng::reseed</code> has been removed since it has no utility over <code>from_seed</code>
and its performance advantage is questionable.</p>
<p>Implementations of <code>SeedableRng</code> may need to change their <code>Seed</code> type to a
byte-array; this restriction has been made to ensure portable handling of
Endianness. Helper functions are available in <code>rand_core::le</code> to read <code>u32</code> and
<code>u64</code> values from byte arrays.</p>
<a class="header" href="#block-based-prngs" id="block-based-prngs"><h3>Block-based PRNGs</h3></a>
<p>rand_core has a new helper trait, <code>BlockRngCore</code>, and implementation,
<code>BlockRng</code>. These are for use by generators which generate a block of random
data at a time instead of word-sized values. Using this trait and implementation
has two advantages: optimised <code>RngCore</code> methods are provided, and the PRNG can
be used with <code>ReseedingRng</code> with very low overhead.</p>
<a class="header" href="#cryptographic-rngs" id="cryptographic-rngs"><h3>Cryptographic RNGs</h3></a>
<p>A new trait has been added: <code>CryptoRng</code>. This is purely a marker trait to
indicate which generators should be suitable for cryptography, e.g.
<code>fn foo&lt;R: Rng + CryptoRng&gt;(rng: &amp;mut R)</code>. <em>Suitability for cryptographic
use cannot be guaranteed.</em></p>
<a class="header" href="#error-handling-1" id="error-handling-1"><h2>Error handling</h2></a>
<p>A new <code>Error</code> type has been added, designed explicitly for no-std compatibility,
simplicity, and enough flexibility for our uses (carrying a <code>cause</code> when
possible):</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
pub struct Error {
    pub kind: ErrorKind,
    pub msg: &amp;'static str,
    // some fields omitted
}
#}</code></pre></pre>
<p>The associated <code>ErrorKind</code> allows broad classification of errors into permanent,
unexpected, transient and not-yet-ready kinds.</p>
<p>The following use the new error type:</p>
<ul>
<li><code>RngCore::try_fill_bytes</code></li>
<li><code>Rng::try_fill</code></li>
<li><code>OsRng::new</code></li>
<li><code>JitterRng::new</code></li>
</ul>
<a class="header" href="#external-generators" id="external-generators"><h2>External generators</h2></a>
<p>We have a new generator, <code>EntropyRng</code>, which wraps <code>OsRng</code> and <code>JitterRng</code>
(preferring to use the former, but falling back to the latter if necessary).
This allows easy construction with fallback via <code>SeedableRng::from_rng</code>,
e.g. <code>IsaacRng::from_rng(EntropyRng::new())?</code>. This is equivalent to using
<code>FromEntropy</code> except for error handling.</p>
<p>It is recommended to use <code>EntropyRng</code> over <code>OsRng</code> to avoid errors on platforms
with broken system generator, but it should be noted that the <code>JitterRng</code>
fallback is very slow.</p>
<a class="header" href="#prngs" id="prngs"><h2>PRNGs</h2></a>
<p><em>Pseudo-Random Number Generators</em> (i.e. deterministic algorithmic generators)
have had a few changes since 0.4, and are now housed in the <code>prng</code> module
(old names remain temporarily available for compatibility; eventually these
generators will likely be housed outside the <code>rand</code> crate).</p>
<p>All PRNGs now do not implement <code>Copy</code> to prevent accidental copying of the
generator's state (and thus repetitions of generated values). Explicit cloning
via <code>Clone</code> is still available. All PRNGs now have a custom implementation of
<code>Debug</code> which does not print any internal state; this helps avoid accidentally
leaking cryptographic generator state in log files. External PRNG
implementations are advised to follow this pattern (see also doc on <code>RngCore</code>).</p>
<p><code>SmallRng</code> has been added as a wrapper, currently around <code>XorShiftRng</code> (but
likely another algorithm soon). This is for uses where small state and fast
initialisation are important but cryptographic strength is not required.
(Actual performance of generation varies by benchmark; depending on usage
this may or may not be the fastest algorithm, but will always be fast.)</p>
<a class="header" href="#reseedingrng" id="reseedingrng"><h3><code>ReseedingRng</code></h3></a>
<p>The <code>ReseedingRng</code> wrapper has been significantly altered to reduce overhead.
Unfortunately the new <code>ReseedingRng</code> is not compatible with all RNGs, but only
those using <code>BlockRngCore</code>.</p>
<a class="header" href="#chacha" id="chacha"><h3>ChaCha</h3></a>
<p>The method <code>ChaChaRng::set_counter</code> has been replaced by two new methods,
<code>set_word_pos</code> and <code>set_stream</code>. Where necessary, the behaviour of the old
method may be emulated as follows:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
# use rand::prelude::*;
# use rand_chacha::ChaChaRng;
let lower = 88293;
let higher = 9300932;

// previously:
// let mut rng = rand::ChaChaRng::new_unseeded();
// rng.set_counter(lower, higher);

// now:
let mut rng = ChaChaRng::from_seed([0u8; 32]);
rng.set_word_pos(lower &lt;&lt; 4);
rng.set_stream(higher);

assert_eq!(4060232610, rng.next_u32());
assert_eq!(2786236710, rng.next_u32());
#}</code></pre></pre>
<a class="header" href="#isaac-prngs" id="isaac-prngs"><h3>ISAAC PRNGs</h3></a>
<p>The <code>IsaacRng</code> and <code>Isaac64Rng</code> PRNGs now have an additional construction
method: <code>new_from_u64(seed)</code>. 64 bits of state is insufficient for cryptography
but may be of use in simulations and games. This will likely be superseded by
a method to construct any PRNG from any hashable object in the future.</p>
<a class="header" href="#hc-128" id="hc-128"><h3>HC-128</h3></a>
<p>This is a new cryptographic generator, selected as one of the &quot;stream ciphers
suitable for widespread adoption&quot; by eSTREAM. This is now the default
cryptographic generator, used by <code>StdRng</code> and <code>thread_rng()</code>.</p>
<a class="header" href="#helper-functionstraits" id="helper-functionstraits"><h2>Helper functions/traits</h2></a>
<p>The <code>Rand</code> trait has been deprecated. Instead, users are encouraged to use
<code>Standard</code> which is a real distribution and supports the same sampling as
<code>Rand</code>. <code>Rng::gen()</code> now uses <code>Standard</code> and should work exactly as before.
See the documentation of the <code>distributions</code> module on how to implement
<code>Distribution&lt;T&gt;</code> for <code>Standard</code> for user types <code>T</code></p>
<p><code>weak_rng()</code> has been deprecated; use <code>SmallRng::from_entropy()</code> instead.</p>
<a class="header" href="#distributions-1" id="distributions-1"><h2>Distributions</h2></a>
<p>The <code>Sample</code> and <code>IndependentSample</code> traits have been replaced by a single
trait, <code>Distribution</code>. This is largely equivalent to <code>IndependentSample</code>, but
with <code>ind_sample</code> replaced by just <code>sample</code>. Support for mutable distributions
has been dropped; although it appears there may be a few genuine uses, these
are not used widely enough to justify the existence of two independent traits
or of having to provide mutable access to a distribution object. Both <code>Sample</code>
and <code>IndependentSample</code> are still available, but deprecated; they will be
removed in a future release.</p>
<p><code>Distribution::sample</code> (as well as several other functions) can now be called
directly on type-erased (unsized) RNGs.</p>
<p><code>RandSample</code> has been removed (see <code>Rand</code> deprecation and new <code>Standard</code>
distribution).</p>
<p>The <code>Closed01</code> wrapper has been removed, but <code>OpenClosed01</code> has been added.</p>
<a class="header" href="#uniform-distributions-1" id="uniform-distributions-1"><h3>Uniform distributions</h3></a>
<p>Two new distributions are available:</p>
<ul>
<li><code>Standard</code> produces uniformly-distributed samples for many different types,
and acts as a replacement for <code>Rand</code></li>
<li><code>Alphanumeric</code> samples <code>char</code>s from the ranges <code>a-z A-Z 0-9</code></li>
</ul>
<a class="header" href="#ranges" id="ranges"><h4>Ranges</h4></a>
<p>The <code>Range</code> distribution has been heavily adapted, and renamed to <code>Uniform</code>:</p>
<ul>
<li><code>Uniform::new(low, high)</code> remains (half open <code>[low, high)</code>)</li>
<li><code>Uniform::new_inclusive(low, high)</code> has been added, including <code>high</code> in the sample range</li>
<li><code>Uniform::sample_single(low, high, rng)</code> is a faster variant for single usage sampling from <code>[low, high)</code></li>
</ul>
<p><code>Uniform</code> can now be implemented for user-defined types; see the <code>uniform</code> module.</p>
<a class="header" href="#non-uniform-distributions" id="non-uniform-distributions"><h3>Non-uniform distributions</h3></a>
<p>Two distributions have been added:</p>
<ul>
<li>Poisson, modeling the number of events expected from a constant-rate
source within a fixed time interval (e.g. nuclear decay)</li>
<li>Binomial, modeling the outcome of a fixed number of yes-no trials</li>
</ul>
<p>The sampling methods are based on those in &quot;Numerical Recipes in C&quot;.</p>
<a class="header" href="#exponential-and-normal-distributions" id="exponential-and-normal-distributions"><h4>Exponential and Normal distributions</h4></a>
<p>The main <code>Exp</code> and <code>Normal</code> distributions are unchanged, however the
&quot;standard&quot; versions, <code>Exp1</code> and <code>StandardNormal</code> are no longer wrapper types,
but full distributions. Instead of writing <code>let Exp1(x) = rng.gen();</code> you now
write <code>let x = rng.sample(Exp1);</code>.</p>
<a class="header" href="#updating-to-06" id="updating-to-06"><h1>Updating to 0.6</h1></a>
<p>During the 0.6 cycle, Rand found a new home under the
<a href="https://github.com/rust-random">rust-random</a> project. We already feel at home,
but if you'd like to help us decorate, a <a href="https://github.com/rust-random/rand/issues/278">new logo</a> would be appreciated!</p>
<p>We also found a new home for user-centric documentation — this book!</p>
<a class="header" href="#prngs-1" id="prngs-1"><h2>PRNGs</h2></a>
<p>All PRNGs in our <a href="https://docs.rs/rand/0.5/rand/prng/index.html">old PRNG module</a>
have been moved to new crates. We also added an additional crate with the PCG
algorithms, and an external crate with Xoshiro / Xoroshiro algorithms:</p>
<ul>
<li><a href="https://crates.io/crates/rand_chacha"><code>rand_chacha</code></a></li>
<li><a href="https://crates.io/crates/rand_hc"><code>rand_hc</code></a></li>
<li><a href="https://crates.io/crates/rand_isaac"><code>rand_isaac</code></a></li>
<li><a href="https://crates.io/crates/rand_xorshift"><code>rand_xorshift</code></a></li>
<li><a href="https://crates.io/crates/rand_pcg"><code>rand_pcg</code></a></li>
<li><a href="https://crates.io/crates/xoshiro"><code>xoshiro</code></a></li>
</ul>
<a class="header" href="#smallrng" id="smallrng"><h3>SmallRng</h3></a>
<p>This update, we switched the algorithm behind <a href="../rand/rand/rngs/struct.SmallRng.html"><code>SmallRng</code></a> from Xorshift to a
PCG algorithm (either <a href="../rand/rand_pcg/type.Pcg64Mcg.html"><code>Pcg64Mcg</code></a> aka XSL 128/64 MCG, or <a href="../rand/rand_pcg/type.Pcg32.html"><code>Pcg32</code></a> aka
XSH RR 64/32 LCG aka the standard PCG algorithm).</p>
<a class="header" href="#sequences-1" id="sequences-1"><h2>Sequences</h2></a>
<p>The <a href="../rand/rand/seq/index.html"><code>seq</code> module</a> has been completely re-written,
and the <code>choose</code> and <code>shuffle</code> methods have been removed from the <a href="../rand/trait.Rng.html"><code>Rng</code></a> trait.
Most functionality can now be found in the <a href="../rand/rand/seq/trait.IteratorRandom.html"><code>IteratorRandom</code></a> and
<a href="../rand/rand/seq/trait.SliceRandom.html"><code>SliceRandom</code></a> traits.</p>
<a class="header" href="#weighted-choices" id="weighted-choices"><h3>Weighted choices</h3></a>
<p>The <a href="https://docs.rs/rand/0.5/rand/distributions/struct.WeightedChoice.html"><code>WeightedChoice</code></a> distribution has now been replaced with
<a href="../rand/rand/distributions/struct.WeightedIndex.html"><code>WeightedIndex</code></a>, solving a few issues by making the functionality more
generic.</p>
<p>For convenience, the <a href="../rand/rand/seq/trait.SliceRandom.html#tymethod.choose_weighted"><code>SliceRandom::choose_weighted</code></a> method (and <code>_mut</code>
variant) allow a <a href="../rand/rand/distributions/struct.WeightedIndex.html"><code>WeightedIndex</code></a> sample to be applied directly to a slice.</p>
<a class="header" href="#other-features" id="other-features"><h2>Other features</h2></a>
<a class="header" href="#simd-types" id="simd-types"><h3>SIMD types</h3></a>
<p>Rand now has rudimentary support for generating SIMD types, gated behind the
<code>simd_support</code> feature flag.</p>
<a class="header" href="#i128--u128-types" id="i128--u128-types"><h3><code>i128</code> / <code>u128</code> types</h3></a>
<p>Since these types are now available on stable compilers, these types are
supported automatically (with recent enough Rust version). The <code>i128_support</code>
feature flag still exists to avoid breakage, but no longer does anything.</p>
<a class="header" href="#updating-to-07" id="updating-to-07"><h1>Updating to 0.7</h1></a>
<p>Since the 0.6 release, <a href="https://github.com/rust-random">rust-random</a>
gained a logo and a new crate: <a href="https://github.com/rust-random/getrandom">getrandom</a>!</p>
<a class="header" href="#dependencies" id="dependencies"><h2>Dependencies</h2></a>
<p>Rand crates now require <code>rustc</code> version 1.32.0 or later.
This allowed us to remove all <code>build.rs</code> files for faster compilation.</p>
<p>The Rand crate now has fewer dependencies overall, though
with some new ones.</p>
<a class="header" href="#getrandom" id="getrandom"><h2>Getrandom</h2></a>
<p>As mentioned above, we have a new crate: <a href="https://github.com/rust-random/getrandom">getrandom</a>, delivering a minimal API
around platform-independent access to fresh entropy. This replaces the previous
implementation in [<code>OsRng</code>], which is now merely a wrapper.</p>
<a class="header" href="#core-features" id="core-features"><h2>Core features</h2></a>
<p>The <a href="https://docs.rs/rand/0.6.0/rand/trait.FromEntropy.html"><code>FromEntropy</code></a> trait has now been removed. Fear not though, its
<a href="https://rust-random.github.io/rand/rand/trait.SeedableRng.html#method.from_entropy"><code>from_entropy</code></a> method continues to provide easy initialisation from its new
home in the <a href="https://rust-random.github.io/rand/rand/trait.SeedableRng.html"><code>SeedableRng</code></a> trait (this requires that <code>rand_core</code> has the <code>std</code>
or <code>getrandom</code> feature enabled):</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
use rand::{SeedableRng, rngs::StdRng};
let mut rng = StdRng::from_entropy();
#}</code></pre></pre>
<p>The <a href="https://rust-random.github.io/rand/rand/trait.SeedableRng.html#method.from_rng"><code>SeedableRng::from_rng</code></a> method is now considered value-stable:
implementations should have portable results.</p>
<p>The <a href="https://rust-random.github.io/rand/rand_core/struct.Error.html"><code>Error</code></a> type of <code>rand_core</code> and <code>rand</code> has seen a major redesign; direct
usage of this type is likely to need adjustment.</p>
<a class="header" href="#prngs-2" id="prngs-2"><h2>PRNGs</h2></a>
<p>These have seen less change than in the previous release, but noteworthy is:</p>
<ul>
<li><a href="https://crates.io/crates/rand_chacha"><code>rand_chacha</code></a> has been rewritten
for much better performance (via SIMD instructions)</li>
<li><a href="../rand/rand/rngs/struct.StdRng.html"><code>StdRng</code></a> and <a href="../rand/rand/rngs/struct.ThreadRng.html"><code>ThreadRng</code></a> now use the ChaCha algorithm. This is a
value-breaking change for <a href="../rand/rand/rngs/struct.StdRng.html"><code>StdRng</code></a>.</li>
<li><a href="../rand/rand/rngs/struct.SmallRng.html"><code>SmallRng</code></a> is now gated behind the <code>small_rng</code> feature flag.</li>
<li>The <code>xoshiro</code> crate is now <a href="https://crates.io/crates/rand_xoshiro"><code>rand_xoshiro</code></a>.</li>
<li><code>rand_pcg</code> now includes <a href="../rand/rand_pcg/type.Pcg64.html"><code>Pcg64</code></a>.</li>
</ul>
<a class="header" href="#distributions-2" id="distributions-2"><h2>Distributions</h2></a>
<p>For the most widely used distributions (<a href="../rand/rand/distributions/struct.Standard.html"><code>Standard</code></a> and <a href="../rand/rand/distributions/struct.Uniform.html"><code>Uniform</code></a>), there have
been no significant changes. But for <em>most</em> of the rest...</p>
<ul>
<li>We added a new crate, [rand_distr], to house the all distributions
(including re-exporting those still within <a href="../rand/rand/distributions/index.html"><code>rand::distributions</code></a>). If you
previously used <a href="../rand/rand/distributions/struct.Normal.html"><code>rand::distributions::Normal</code></a>, now you use
<a href="../rand/rand_distr/struct.Normal.html"><code>rand_distr::Normal</code></a>.</li>
<li>Constructors for many distributions changed in order to return a <code>Result</code>
instead of panicking on error.</li>
<li>Many distributions are now generic over their parameter type (in most cases
supporting <code>f32</code> and <code>f64</code>). This aids usage with generic code, and allows
reduced size of parameterised distributions. Currently the more complex
algorithms always use <code>f64</code> internally.</li>
<li><a href="../rand/rand/distributions/struct.Standard.html"><code>Standard</code></a> can now sample <a href="https://doc.rust-lang.org/std/num/index.html"><code>NonZeroU*</code></a> values</li>
</ul>
<p>We also added several distributions:</p>
<ul>
<li><a href="../rand/rand/distributions/alias_method/struct.WeightedIndex.html"><code>rand::distributions::weighted::alias_method::WeightedIndex</code></a></li>
<li><a href="../rand/rand_distr/struct.Pert.html"><code>rand_distr::Pert</code></a></li>
<li><a href="../rand/rand_distr/struct.Triangular.html"><code>rand_distr::Triangular</code></a></li>
<li><a href="../rand/rand_distr/struct.UnitBall.html"><code>rand_distr::UnitBall</code></a></li>
<li><a href="../rand/rand_distr/struct.UnitDisc.html"><code>rand_distr::UnitDisc</code></a></li>
<li><a href="../rand/rand_distr/struct.UnitSphere.html"><code>rand_distr::UnitSphere</code></a> (previously named <code>rand::distributions::UnitSphereSurface</code>)</li>
</ul>
<a class="header" href="#sequences-2" id="sequences-2"><h2>Sequences</h2></a>
<p>To aid portability, all random samples of type <code>usize</code> now instead sample a
<code>u32</code> value when the upper-bound is less than <code>u32::MAX</code>. This means that
upgrading to 0.7 is a value-breaking change for use of <code>seq</code> functionality, but
that after upgrading to 0.7 results should be consistent across CPU
architectures.</p>
<a class="header" href="#contributing" id="contributing"><h1>Contributing</h1></a>
<p>Thank you for your interest in contributing to Rand!</p>
<p>We are open to all contributors, but please consider that we have limited
resources, usually have other on-going work within the project, and that even
accepting complete PRs costs us time (review and potentially on-going support),
thus we may take considerable time to get back to you.</p>
<a class="header" href="#all-contributions" id="all-contributions"><h2>All contributions</h2></a>
<ul>
<li>
<p><strong>Scope:</strong> please consider whether your &quot;issue&quot; falls within the existing
scope of the project or is an enhancement. Note that whether something is
considered a <em>defect</em> may depend on your point of view. We may choose to
reject contributions to avoid increasing our workload.</p>
<p>If you wish to expand the scope of the project (e.g. new platforms or
additional CI testing) then please be prepared to provide on-going
support.</p>
</li>
<li>
<p><strong>Fixes:</strong> if you can easily fix this yourself, please consider making a PR
instead of opening an issue. On the other hand if it's less easy or looks
like it may conflict with other work, don't hesistate to open an issue.</p>
</li>
</ul>
<a class="header" href="#pull-requests" id="pull-requests"><h2>Pull Requests</h2></a>
<ul>
<li>
<p><strong>Changelog:</strong> unless your change is trivial, please include a note in the
changelog (<code>CHANGELOG.md</code>) of each crate affected, under the <code>[Unreleased]</code>
heading at the top (add if necessary). Please include the PR number (this
implies the note must be added <em>after</em> opening a PR).</p>
</li>
<li>
<p><strong>Commits:</strong> if contributing large changes, consider splitting these over
multiple commits, if possible such that each commit at least compiles.
Rebasing commits may be appropriate when making significant changes.</p>
</li>
<li>
<p><strong>Documentation:</strong> we require documentation of all public items. Short
examples may be included where appropriate.</p>
</li>
<li>
<p><strong>Maintainability:</strong> it is important to us that code is easy to read and
understand and not hard to review for correctness.</p>
</li>
<li>
<p><strong>Performance:</strong> we always aim for good performance and sometimes do
considerable extra work to get there, however we must also make compromises
for the sake of maintainability, and consider whether a minor efficiency
gain is worth the extra code complexity. <a href="contrib-bench.html">Use benchmarks</a>.</p>
</li>
<li>
<p><strong>Style:</strong> make it neat. <em>Usually</em> limit length to 80 chars.</p>
</li>
<li>
<p><strong>Unsafe:</strong> use it where necessary, not if there is a good alternative.
Ensure <code>unsafe</code> code is easy to review for correctness.</p>
</li>
<li>
<p><strong>License and attribution:</strong> this project is freely licenced under the MIT
and Apache Public Licence v2. We assume that all contributions are made
under these licence grants. Copyrights are retained by their contributors.</p>
<p>Our works are attributed to &quot;The Rand Project Developers&quot;. This is not a
formal entity but merely the collection of all contributors to this project.
For more, see the <a href="COPYRIGHT">COPYRIGHT</a> file.</p>
</li>
<li>
<p><strong>Thank you!</strong></p>
</li>
</ul>
<a class="header" href="#documentation" id="documentation"><h1>Documentation</h1></a>
<a class="header" href="#style" id="style"><h3>Style</h3></a>
<p>All documentation is in English, but no particular dialect is preferred.</p>
<p>The documentation should be accessible to multiple audiences: both seasoned
Rustaceans and relative newcomers, those with experience in statistical
modelling or cryptography, as well as those new to the subjects. Since it is
often impossible to write appropriate one-size-fits-all documentation, we
prefer concise technical documentation with reference to extended articles
aimed at more specific audiences.</p>
<a class="header" href="#api-documentation" id="api-documentation"><h2>API documentation</h2></a>
<a class="header" href="#rand-crates" id="rand-crates"><h3>Rand crates</h3></a>
<p>It is recommended to use nightly Rust for correct link handling.</p>
<p>To build all API documentation for all crates in the
<a href="https://github.com/rust-random/rand">rust-random/rand</a> repository, run:</p>
<pre><code class="language-sh"># Build doc for all modules:
cargo doc --all --no-deps

# And open it:
xdg-open target/doc/rand/index.html
</code></pre>
<p>On Linux, it is easy to set up automatic rebuilds after any edit:</p>
<pre><code class="language-sh">while inotifywait -r -e close_write src/ rand_*/; do cargo doc; done
</code></pre>
<p>After editing API documentation, we reccomend testing examples and
checking for broken links:</p>
<pre><code class="language-sh">cargo test --doc

cargo install cargo-deadlinks
# It is recommended to remove left-over files from previous compilations
rm -rf /target/doc
cargo doc --all --no-deps
cargo deadlinks --dir target/doc
</code></pre>
<p>Rand API docs are automatically built and hosted at
<a href="https://rust-random.github.io/rand">rust-random.github.io/rand</a> for the latest code in master.</p>
<a class="header" href="#getrandom-crate" id="getrandom-crate"><h3>Getrandom crate</h3></a>
<p>The <a href="https://github.com/rust-random/getrandom">rust-random/getrandom</a>
repository contains only a single crate, hence a simple <code>cargo doc</code> will
suffice.</p>
<a class="header" href="#cross-crate-links" id="cross-crate-links"><h3>Cross-crate links</h3></a>
<p>When referring to another crate, we prefer linking to the crate page on
crates.io since (a) this includes the README documenting the purpose of the
crate and (b) this links directly to both the repository and the API
documentation. Example:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
// Link to the crate page:
//! [`rand_chacha`]: https://crates.io/crates/rand_chacha
#}</code></pre></pre>
<p>When referring to an item from within another crate,</p>
<ol>
<li>if that item is accessible via a crate dependency (even if not via the
public API), use the Rust item path</li>
<li>when linking to another crate within the <code>rust-random/rand</code> repository,
relative paths within the generated documentation files (under <code>target/doc</code>)
can be used; these work on <a href="https://rust-random.github.io/rand">rust-random.github.io/rand</a> but not
currently on <code>docs.rs</code> (see <a href="https://github.com/rust-lang/docs.rs/issues/204">docs#204</a>)</li>
<li>if neither of the above are applicable, use an absolute link</li>
<li>consider revising documentation, e.g. refer to the crate instead</li>
</ol>
<p>Examples:</p>
<pre><code>// We depend on rand_core, therefore can use the Rust path:
/// [`BlockRngCore`]: rand_core::block::BlockRngCore

// rand_chacha is not a dependency, but is within the same repository:
//! [`ChaCha20Rng`]: ../../rand_chacha/struct.ChaCha20Rng.html

// Link directly to docs.rs, with major &amp; minor but no patch version:
https://docs.rs/getrandom/0.1/getrandom/fn.getrandom.html
</code></pre>
<a class="header" href="#auxilliary-documentation" id="auxilliary-documentation"><h2>Auxilliary documentation</h2></a>
<a class="header" href="#readme-files" id="readme-files"><h3>README files</h3></a>
<p>README files contain a brief introduction to the crate, shield badges, useful
links, feature-flag documentation, licence information, and potentially an
example.</p>
<p>For the most part these files do not have any continuous testing.
Where examples are included (currently only for the <code>rand_jitter</code> crate),
we enable continuous testing via <code>doc_comment</code> (see
<a href="https://github.com/rust-random/rand/blob/master/rand_jitter/src/lib.rs#L62">lib.rs:62 onwards</a>).</p>
<a class="header" href="#changelog-files" id="changelog-files"><h3>CHANGELOG files</h3></a>
<p>Changelog formats are based on the
<a href="http://keepachangelog.com/en/1.0.0/">Keep a Changelog</a> format.</p>
<p>All significant changes merged since the last release should be listed under an
<code>[Unreleased]</code> section at the top of log.</p>
<a class="header" href="#the-book" id="the-book"><h3>The book</h3></a>
<p>The source to this book is contained in the
<a href="https://github.com/rust-random/book">rust-random/book</a> repository.
It is built using mdbook, which makes building and testing easy:</p>
<pre><code class="language-sh">cargo install mdbook --version &quot;^0.2&quot;

mdbook build --open
mdbook test

# To automatically rebuild after any changes:
mdbook watch
</code></pre>
<p>Note that links in the book are relative and designed to work in the
<a href="https://rust-random.github.io/book/">published book</a>. If you build the book
locally, you might want to set up a symbolic link pointing to your build of the
API documentation:</p>
<pre><code class="language-sh">ln -s ../rand/target/doc rand
</code></pre>
<a class="header" href="#scope" id="scope"><h1>Scope</h1></a>
<p>Over time, the scope of the project has grown, and Rand has moved from using a
monolithic crate to using a &quot;main&quot; crate plus multiple single-purpose crates.
For new functionality, one must consider where, and whether, it fits within the
Rand project.</p>
<p>Small, focussed crates may be used for a few reasons, but we aim <em>not</em> to
maximally divide functionality into small crates. Valid reasons for using a
separate crate for a feature are therefore:</p>
<ul>
<li>to allow a clear dependency hierarchy (<code>rand_core</code>)</li>
<li>to make the feature available in a stand-alone fashion (e.g. <code>getrandom</code>)</li>
<li>to remove little-used features with non-trivial amounts of code from widely
used crates (e.g. <code>rand_jitter</code> and <code>rand_distr</code> both extracted
functionality from <code>rand</code>)</li>
<li>to allow choice, without including large amounts of unused code for all
users, but also without producing an enormous number of new crates
(RNG family crates like <code>rand_xoshiro</code> and <code>rand_isaac</code>)</li>
</ul>
<a class="header" href="#traits-basics-and-ui" id="traits-basics-and-ui"><h2>Traits, basics and UI</h2></a>
<p>The main user interface to the Rand project remains the central <code>rand</code> crate.
Goals for this crate are:</p>
<ul>
<li>ease of use</li>
<li>expose commonly used functionality in a single place</li>
<li>permit usage of additional randomness sources and distribution samplers</li>
</ul>
<p>To allow better modularity, the core traits have been moved to the <code>rand_core</code>
crate. Goals of this crate are:</p>
<ul>
<li>expose the core traits with minimal dependencies</li>
<li>provide common tools needed to implement various randomness sources</li>
</ul>
<a class="header" href="#external-random-sources" id="external-random-sources"><h2>External random sources</h2></a>
<p>The main (and usually only) external source of randomness is the Operating
System, interfaced via the <code>getrandom</code> crate. This crate also supports usage of
RDRAND on a few <code>no_std</code> targets.</p>
<p>Support for other <code>no_std</code> targets has been discussed but with little real
implementation effort. See
<a href="https://github.com/rust-random/getrandom/issues/4">getrandom#4</a>.</p>
<p>The <code>rand_jitter</code> crate provides an implementation of a
<a href="http://www.chronox.de/jent.html">CPU Jitter</a> entropy harvestor, and is only
included in Rand for historical reasons.</p>
<p>The <code>rand_os</code> crate proves an <code>RngCore</code> implementation around <code>getrandom</code>.</p>
<a class="header" href="#pseudo-random-generators" id="pseudo-random-generators"><h2>Pseudo-random generators</h2></a>
<p>The Rand library includes several pseudo-random number generators, for the
following reasons:</p>
<ul>
<li>to implement the <code>StdRng</code> and <code>SmallRng</code> generators</li>
<li>to provide a few high-quality alternative generators</li>
<li>historical usage</li>
</ul>
<p>These are implemented within &quot;family&quot; crates, e.g. <code>rand_chacha</code>, <code>rand_pcg</code>,
<code>rand_xoshiro</code>.</p>
<p>We have received several requests to adopt new algorithms into the library; when
evaluating such requests we must consider several things:</p>
<ul>
<li>purpose for inclusion within Rand</li>
<li>whether the PRNG is cryptographically secure, and if so, how trustworthy
such claims are</li>
<li>statistical quality of output</li>
<li>performance and features of the generator</li>
<li>reception and third-party review of the algorithm</li>
</ul>
<a class="header" href="#distributions-3" id="distributions-3"><h2>Distributions</h2></a>
<p>The <code>Distribution</code> trait is provided by Rand, along with commonly-used
distributions (mostly linear ones).</p>
<p>Additional distributions are packaged within the <code>rand_distr</code> crate, which
depends on <code>rand</code> and re-exports all of its distributions.</p>
<a class="header" href="#testing" id="testing"><h1>Testing</h1></a>
<p>Rand has a number of unit tests, though these are not comprehensive or perfect
(improvements welcome). We prefer to have tests for all new functionality.</p>
<p>The first line of testing is simply to run <code>cargo test</code> from the appropriate
directory. Since Rand supports <code>no_std</code> (core-only), <code>core+alloc</code> and <code>std</code>
environments, it is important to test all three (depending on which features
are applicable to the code in question):</p>
<pre><code class="language-sh"># Test using std:
cargo test
# Test using only core:
cargo test --tests --no-default-features
# Test using core + alloc (requires nightly):
cargo +nightly test --tests --no-default-features --features=alloc
</code></pre>
<p>It may also be worth testing with other feature flags:</p>
<pre><code class="language-sh">cargo test --all-features
</code></pre>
<p>Note that this only tests the current package (i.e. the main Rand lib when run
from the repo's top level). To test another lib, <code>cd</code> to its directory.</p>
<p>We do not recommend using Cargo's <code>--package</code> option due to its
<a href="https://github.com/rust-lang/cargo/issues/5364">surprising interactions</a>
with <code>--feature</code> options and failure when multiple versions of the same package
are in the build tree. The CI instead uses <code>--manifest-path</code> to select packages;
while developing, using <code>cd</code> is easier.</p>
<a class="header" href="#writing-tests" id="writing-tests"><h2>Writing tests</h2></a>
<p>Tests may be unit tests within a <code>test</code> sub-module, documentation examples,
example applications (<code>examples</code> dir), integration tests (<code>tests</code> dir), or
benchmarks (<code>benches</code> dir).</p>
<p>Note that <em>only</em> unit tests and integration tests are expected to pass in
<code>no_std</code> (core only) and <code>core+alloc</code> configurations. This is a deliberate
choice; example code should only need to target the common case (<code>std</code>).</p>
<a class="header" href="#random-number-generators" id="random-number-generators"><h3>Random Number Generators</h3></a>
<p>Often test code needs some RNG to test with, but does not need any particular
RNG. In this case, we prefer use of <code>::test::rng</code> which is simple, fast to
initialise and deterministic:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
let mut rng = ::test::rng(528); // just pick some number
#}</code></pre></pre>
<p>Various tests concern properties which are <em>probably</em> true, but not definitely.
We prefer that such tests are deterministic to avoid spurious failures.</p>
<a class="header" href="#benchmarks" id="benchmarks"><h1>Benchmarks</h1></a>
<p>We already have many benchmarks:</p>
<pre><code class="language-sh">cargo +nightly bench

# In a few cases, nightly features may use different code paths:
cargo +nightly bench --features=nightly
</code></pre>
<p>Benchmarks for distributions now live in the <code>rand_distr</code> crate; all other
benchmarks (including all our RNGs) live in the main <code>rand</code> crate
(hence the many dev-dependencies).</p>
<p>A lot of code in Rand is performance sensitive, most of it is expected to be
used in hot loops in some libraries/applications. If you change code in
<code>rand_core</code>, in PRNG crates, or in the <code>rngs</code> or <code>distributions</code> modules
(especially when an 'obvious cleanup'), make sure the benchmarks do not regress.</p>
<p>Please report before-and-after results for any affected benchmarks. If you are
optimising something previously not benchmarked, please add new benchmarks
first, then add your changes in a separate commit (to make before-and-after
benchmarking easy).</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                        

                        

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                

                
            </nav>

        </div>

        

        

        

        
        <script src="elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="searcher.js" type="text/javascript" charset="utf-8"></script>
        

        <script src="clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->
        

        
        
        <script type="text/javascript">
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>
        
        

    </body>
</html>
